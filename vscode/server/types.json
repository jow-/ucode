{
	"core": {
		"print": {
			"kind": "function",
			"name": "module:core#print",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "values",
					"description": "Arbitrary values to print"
				}
			},
			"subject": "Print any of the given values to stdout.",
			"description": "Print any of the given values to stdout.\n\nThe `print()` function writes a string representation of each given argument\nto stdout and returns the amount of bytes written.\n\nString values are printed as-is, integer and double values are printed in\ndecimal notation, boolean values are printed as `true` or `false` while\narrays and objects are converted to their JSON representation before being\nwritten to the standard output. The `null` value is represented by an empty\nstring so `print(null)` would print nothing. Resource values are printed in\nthe form `<type address>`, e.g. `<fs.file 0x7f60f0981760>`.\n\nIf resource, array or object values contain a `tostring()` function in their\nprototypes, then this function is invoked to obtain an alternative string\nrepresentation of the value.\n\nExamples:\n\n```javascript\nprint(1 != 2);                       // Will print 'true'\nprint(0xff);                         // Will print '255'\nprint(2e3);                          // Will print '2000'\nprint(null);                         // Will print nothing\nprint({ hello: true, world: 123 });  // Will print '{ \"hello\": true, \"world\": 123 }'\nprint([1,2,3]);                      // Will print '[ 1, 2, 3 ]'\n\nprint(proto({ foo: \"bar\" },          // Will print 'MyObj'\n{ tostring: () => \"MyObj\" }));     // instead of '{ \"foo\": \"bar\" }'\n\n```\n\nReturns the amount of bytes printed."
		},
		"length": {
			"kind": "function",
			"name": "module:core#length",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"description": "Determine the length of the given object, array or string.\n\nReturns the length of the given value.\n\n- For strings, the length is the amount of bytes within the string\n- For arrays, the length is the amount of array elements\n- For objects, the length is defined as the amount of keys\n\nReturns `null` if the given argument is not an object, array or string.",
			"params": {
				"x": {
					"type": [
						{
							"type": "object"
						},
						{
							"type": "array"
						},
						{
							"type": "string"
						}
					],
					"name": "x",
					"description": "The input object, array, or string."
				}
			},
			"subject": "Determine the length of the given object, array or string."
		},
		"index": {
			"kind": "function",
			"name": "module:core#index",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"arr_or_str": {
					"type": [
						{
							"type": "array"
						},
						{
							"type": "string"
						}
					],
					"name": "arr_or_str",
					"description": "The array or string to search for the value."
				},
				"needle": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "needle",
					"description": "The value to find within the array or string."
				}
			},
			"subject": "Finds the given value passed as the second argument within the array or\nstring specified in the first argument.",
			"description": "Finds the given value passed as the second argument within the array or\nstring specified in the first argument.\n\nReturns the first matching array index or first matching string offset or\n`-1` if the value was not found.\n\nReturns `null` if the first argument was neither an array nor a string."
		},
		"rindex": {
			"kind": "function",
			"name": "module:core#rindex",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"arr_or_str": {
					"type": [
						{
							"type": "array"
						},
						{
							"type": "string"
						}
					],
					"name": "arr_or_str",
					"description": "The array or string to search for the value."
				},
				"needle": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "needle",
					"description": "The value to find within the array or string."
				}
			},
			"subject": "Finds the given value passed as the second argument within the array or\nstring specified in the first argument.",
			"description": "Finds the given value passed as the second argument within the array or\nstring specified in the first argument.\n\nReturns the last matching array index or last matching string offset or\n`-1` if the value was not found.\n\nReturns `null` if the first argument was neither an array nor a string."
		},
		"push": {
			"kind": "function",
			"name": "module:core#push",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The array to push values to."
				},
				"values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[values]",
					"description": "The values to push.",
					"optional": true
				}
			},
			"subject": "Pushes the given argument(s) to the given array.",
			"description": "Pushes the given argument(s) to the given array.\n\nReturns the last pushed value."
		},
		"pop": {
			"kind": "function",
			"name": "module:core#pop",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The input array."
				}
			},
			"subject": "Pops the last item from the given array and returns it.",
			"description": "Pops the last item from the given array and returns it.\n\nReturns `null` if the array was empty or if a non-array argument was passed."
		},
		"shift": {
			"kind": "function",
			"name": "module:core#shift",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The array from which to pop the first item."
				}
			},
			"subject": "Pops the first item from the given array and returns it.",
			"description": "Pops the first item from the given array and returns it.\n\nReturns `null` if the array was empty or if a non-array argument was passed."
		},
		"unshift": {
			"kind": "function",
			"name": "module:core#unshift",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The array to which the values will be added."
				},
				"Values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "Values",
					"description": "to add."
				}
			},
			"subject": "Add the given values to the beginning of the array passed via first argument.",
			"description": "Add the given values to the beginning of the array passed via first argument.\n\nReturns the last value added to the array."
		},
		"chr": {
			"kind": "function",
			"name": "module:core#chr",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"n1": {
					"type": [
						{
							"type": "...number"
						}
					],
					"name": "n1",
					"description": "The numeric values."
				}
			},
			"subject": "Converts each given numeric value to a byte and return the resulting string.\nInvalid numeric values or values < 0 result in `\\0` bytes, values larger than\n255 are truncated to 255.",
			"description": "Converts each given numeric value to a byte and return the resulting string.\nInvalid numeric values or values < 0 result in `\\0` bytes, values larger than\n255 are truncated to 255.\n\nReturns a new strings consisting of the given byte values."
		},
		"die": {
			"kind": "function",
			"name": "module:core#die",
			"throws": [
				{
					"type": [
						{
							"type": "Error"
						}
					],
					"description": "The error with the given message."
				}
			],
			"params": {
				"msg": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "msg",
					"description": "The error message."
				}
			},
			"subject": "Raise an exception with the given message and abort execution.",
			"description": "Raise an exception with the given message and abort execution."
		},
		"exists": {
			"kind": "function",
			"name": "module:core#exists",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"obj": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "obj",
					"description": "The input object."
				},
				"key": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "key",
					"description": "The key to check for existence."
				}
			},
			"subject": "Check whether the given key exists within the given object value.",
			"description": "Check whether the given key exists within the given object value.\n\nReturns `true` if the given key is present within the object passed as the\nfirst argument, otherwise `false`."
		},
		"exit": {
			"kind": "function",
			"name": "module:core#exit",
			"params": {
				"n": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "n",
					"description": "The exit code."
				}
			},
			"subject": "Terminate the interpreter with the given exit code.",
			"description": "Terminate the interpreter with the given exit code.\n\nThis function does not return."
		},
		"getenv": {
			"kind": "function",
			"name": "module:core#getenv",
			"return": [
				{
					"type": "string"
				},
				{
					"type": "object",
					"keytype": [
						{
							"type": "string"
						}
					],
					"itemtype": [
						{
							"type": "string"
						}
					]
				}
			],
			"params": {
				"name": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[name]",
					"description": "The name of the environment variable.",
					"optional": true
				}
			},
			"subject": "Query an environment variable or then entire environment.",
			"description": "Query an environment variable or then entire environment.\n\nReturns the value of the given environment variable, or - if omitted - a\ndictionary containing all environment variables."
		},
		"filter": {
			"kind": "function",
			"name": "module:core#filter",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The input array."
				},
				"fn": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "fn",
					"description": "The filter function."
				}
			},
			"subject": "Filter the array passed as the first argument by invoking the function\nspecified in the second argument for each array item.",
			"description": "Filter the array passed as the first argument by invoking the function\nspecified in the second argument for each array item.\n\nIf the invoked function returns a truthy result, the item is retained,\notherwise, it is dropped. The filter function is invoked with three\narguments:\n\n1. The array value\n2. The current index\n3. The array being filtered\n\n(Note that the `map` function behaves similarly to `filter` with respect\nto its `fn` parameters.)\n\nReturns a new array containing only retained items, in the same order as\nthe input array."
		},
		"hex": {
			"kind": "function",
			"name": "module:core#hex",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "x",
					"description": "The hexadecimal string to be converted."
				}
			},
			"subject": "Converts the given hexadecimal string into a number.",
			"description": "Converts the given hexadecimal string into a number.\n\nReturns the resulting integer value or `NaN` if the input value cannot be\ninterpreted as hexadecimal number."
		},
		"int": {
			"kind": "function",
			"name": "module:core#int",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "x",
					"description": "The value to be converted to an integer."
				},
				"base": {
					"type": [
						{
							"type": "int"
						}
					],
					"name": "[base]",
					"description": "The base into which the value is to be converted, the default is 10.\nNote that the base parameter is ignored if the `x` value is already numeric.",
					"optional": true
				}
			},
			"subject": "Converts the given value to an integer, using an optional base.",
			"description": "Converts the given value to an integer, using an optional base.\n\nReturns `NaN` if the value is not convertible."
		},
		"join": {
			"kind": "function",
			"name": "module:core#join",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"sep": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "sep",
					"description": "The separator to be used in joining the array elements."
				},
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The array to be joined into a string."
				}
			},
			"subject": "Joins the array passed as the second argument into a string, using the\nseparator passed in the first argument as glue.",
			"description": "Joins the array passed as the second argument into a string, using the\nseparator passed in the first argument as glue.\n\nReturns `null` if the second argument is not an array."
		},
		"keys": {
			"kind": "function",
			"name": "module:core#keys",
			"return": [
				{
					"type": "array",
					"nullable": true
				}
			],
			"params": {
				"obj": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "obj",
					"description": "The object from which to retrieve the key names."
				}
			},
			"subject": "Enumerates all object key names.",
			"description": "Enumerates all object key names.\n\nReturns an array of all key names present in the passed object.\nReturns `null` if the given argument is not an object."
		},
		"lc": {
			"kind": "function",
			"name": "module:core#lc",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"description": "Convert the given string to lowercase and return the resulting string.\n\nReturns `null` if the given argument could not be converted to a string.",
			"params": {
				"s": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "s",
					"description": "The input string."
				}
			},
			"subject": "Convert the given string to lowercase and return the resulting string."
		},
		"map": {
			"kind": "function",
			"name": "module:core#map",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The input array."
				},
				"fn": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "fn",
					"description": "The mapping function."
				}
			},
			"subject": "Transform the array passed as the first argument by invoking the function\nspecified in the second argument for each array item.",
			"description": "Transform the array passed as the first argument by invoking the function\nspecified in the second argument for each array item.\n\nThe mapping function is invoked with three arguments (see examples, below,\nfor some possibly counterintuitive usage):\n\n1. The array value\n2. The current index\n3. The array being filtered\n\n(Note that the `filter` function behaves similarly to `map` with respect\nto its `fn` parameters.)\n\nReturns a new array of the same length as the input array containing the\ntransformed values."
		},
		"ord": {
			"kind": "function",
			"name": "module:core#ord",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"s": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "s",
					"description": "The input string."
				},
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[offset]",
					"description": "The offset of the character.",
					"optional": true
				}
			},
			"subject": "Without further arguments, this function returns the byte value of the first\ncharacter in the given string.",
			"description": "Without further arguments, this function returns the byte value of the first\ncharacter in the given string.\n\nIf an offset argument is supplied, the byte value of the character at this\nposition is returned. If an invalid index is supplied, the function will\nreturn `null`. Negative index entries are counted towards the end of the\nstring, e.g. `-2` will return the value of the second last character.\n\nReturns the byte value of the character.\nReturns `null` if the offset is invalid or if the input is not a string."
		},
		"type": {
			"kind": "function",
			"name": "module:core#type",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "x",
					"description": "The value to determine the type of."
				}
			},
			"subject": "Query the type of the given value.",
			"description": "Query the type of the given value.\n\nReturns the type of the given value as a string which might be one of\n`\"function\"`, `\"object\"`, `\"array\"`, `\"double\"`, `\"int\"`, or `\"bool\"`.\n\nReturns `null` when no value or `null` is passed."
		},
		"reverse": {
			"kind": "function",
			"name": "module:core#reverse",
			"return": [
				{
					"type": "(Array|string)",
					"nullable": true
				}
			],
			"params": {
				"arr_or_str": {
					"type": [
						{
							"type": "array"
						},
						{
							"type": "string"
						}
					],
					"name": "arr_or_str",
					"description": "The input array or string."
				}
			},
			"subject": "Reverse the order of the given input array or string.",
			"description": "Reverse the order of the given input array or string.\n\nIf an array is passed, returns the array in reverse order.\nIf a string is passed, returns the string with the sequence of the characters\nreversed.\n\nReturns the reversed array or string.\nReturns `null` if neither an array nor a string were passed."
		},
		"sort": {
			"kind": "function",
			"name": "module:core#sort",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The input array to be sorted."
				},
				"fn": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "[fn]",
					"description": "The sort function.",
					"optional": true
				}
			},
			"subject": "Sort the given array according to the given sort function.\nIf no sort function is provided, a default ascending sort order is applied.",
			"description": "Sort the given array according to the given sort function.\nIf no sort function is provided, a default ascending sort order is applied.\n\nThe input array is sorted in-place, no copy is made.\n\nThe custom sort function is repeatedly called until the entire array is\nsorted. It will receive two values as arguments and should return a value\nlower than, larger than or equal to zero depending on whether the first\nargument is smaller, larger or equal to the second argument respectively.\n\nReturns the sorted input array."
		},
		"splice": {
			"kind": "function",
			"name": "module:core#splice",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The input array to be modified."
				},
				"off": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "off",
					"description": "The index to start removing elements."
				},
				"len": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[len]",
					"description": "The number of elements to remove.",
					"optional": true
				},
				"elements": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[elements]",
					"description": "The elements to insert.",
					"optional": true
				}
			},
			"subject": "Removes the elements designated by `off` and `len` from the given array,\nand replaces them with the additional arguments passed, if any.",
			"description": "Removes the elements designated by `off` and `len` from the given array,\nand replaces them with the additional arguments passed, if any.\n\nThe array grows or shrinks as necessary.\n\nReturns the modified input array."
		},
		"slice": {
			"kind": "function",
			"name": "module:core#slice",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "arr",
					"description": "The source array to be copied."
				},
				"off": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[off]",
					"description": "The index of the first element to copy.",
					"optional": true
				},
				"end": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[end]",
					"description": "The index of the first element to exclude from the returned array.",
					"optional": true
				}
			},
			"subject": "Performs a shallow copy of a portion of the source array, as specified by\nthe start and end offsets. The original array is not modified.",
			"description": "Performs a shallow copy of a portion of the source array, as specified by\nthe start and end offsets. The original array is not modified.\n\nReturns a new array containing the copied elements, if any.\nReturns `null` if the given source argument is not an array value."
		},
		"split": {
			"kind": "function",
			"name": "module:core#split",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The input string to be split."
				},
				"sep": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "RegExp"
						}
					],
					"name": "sep",
					"description": "The separator."
				},
				"limit": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[limit]",
					"description": "The limit on the number of splits.",
					"optional": true
				}
			},
			"subject": "Split the given string using the separator passed as the second argument\nand return an array containing the resulting pieces.",
			"description": "Split the given string using the separator passed as the second argument\nand return an array containing the resulting pieces.\n\nIf a limit argument is supplied, the resulting array contains no more than\nthe given amount of entries, that means the string is split at most\n`limit - 1` times total.\n\nThe separator may either be a plain string or a regular expression.\n\nReturns a new array containing the resulting pieces."
		},
		"substr": {
			"kind": "function",
			"name": "module:core#substr",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The input string."
				},
				"off": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "off",
					"description": "The starting offset."
				},
				"len": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[len]",
					"description": "The length of the substring.",
					"optional": true
				}
			},
			"subject": "Extracts a substring out of `str` and returns it. First character is at\noffset zero.",
			"description": "Extracts a substring out of `str` and returns it. First character is at\noffset zero.\n\n- If `off` is negative, starts that far back from the end of the string.\n- If `len` is omitted, returns everything through the end of the string.\n- If `len` is negative, leaves that many characters off the string end.\n\nReturns the extracted substring."
		},
		"time": {
			"kind": "function",
			"name": "module:core#time",
			"return": [
				{
					"type": "number"
				}
			],
			"subject": "Returns the current UNIX epoch.",
			"description": "Returns the current UNIX epoch."
		},
		"uc": {
			"kind": "function",
			"name": "module:core#uc",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "str",
					"description": "The string to be converted to uppercase."
				}
			},
			"subject": "Converts the given string to uppercase and returns the resulting string.",
			"description": "Converts the given string to uppercase and returns the resulting string.\n\nReturns null if the given argument could not be converted to a string."
		},
		"uchr": {
			"kind": "function",
			"name": "module:core#uchr",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"Numeric": {
					"type": [
						{
							"type": "...number"
						}
					],
					"name": "Numeric",
					"description": "values to convert."
				}
			},
			"subject": "Converts each given numeric value to an UTF-8 multibyte sequence and returns\nthe resulting string.",
			"description": "Converts each given numeric value to an UTF-8 multibyte sequence and returns\nthe resulting string.\n\nInvalid numeric values or values outside the range `0`..`0x10FFFF` are\nrepresented by the unicode replacement character `0xFFFD`.\n\nReturns a new UTF-8 encoded string consisting of unicode characters\ncorresponding to the given numeric codepoints."
		},
		"values": {
			"kind": "function",
			"name": "module:core#values",
			"return": [
				{
					"type": "array",
					"nullable": true
				}
			],
			"params": {
				"obj": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "obj",
					"description": "The object from which to extract values."
				}
			},
			"subject": "Returns an array containing all values of the given object.",
			"description": "Returns an array containing all values of the given object.\n\nReturns null if no object was passed."
		},
		"trim": {
			"kind": "function",
			"name": "module:core#trim",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The string to be trimmed."
				},
				"c": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[c]",
					"description": "The characters to be trimmed from the start and end of the string.",
					"optional": true
				}
			},
			"subject": "Trim any of the specified characters in `c` from the start and end of `str`.\nIf the second argument is omitted, trims the characters, ` ` (space), `\\t`,\n`\\r`, and `\\n`.",
			"description": "Trim any of the specified characters in `c` from the start and end of `str`.\nIf the second argument is omitted, trims the characters, ` ` (space), `\\t`,\n`\\r`, and `\\n`.\n\nReturns the trimmed string."
		},
		"ltrim": {
			"kind": "function",
			"name": "module:core#ltrim",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"s": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "s",
					"description": "The input string."
				},
				"c": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[c]",
					"description": "The characters to trim.",
					"optional": true
				}
			},
			"subject": "Trim any of the specified characters from the start of the string.\nIf the second argument is omitted, trims the characters ` ` (space), '\\t',\n'\\r', and '\\n'.",
			"description": "Trim any of the specified characters from the start of the string.\nIf the second argument is omitted, trims the characters ` ` (space), '\\t',\n'\\r', and '\\n'.\n\nReturns the left trimmed string."
		},
		"rtrim": {
			"kind": "function",
			"name": "module:core#rtrim",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The input string."
				},
				"c": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[c]",
					"description": "The characters to trim.",
					"optional": true
				}
			},
			"subject": "Trim any of the specified characters from the end of the string.\nIf the second argument is omitted, trims the characters ` ` (space), '\\t',\n'\\r', and '\\n'.",
			"description": "Trim any of the specified characters from the end of the string.\nIf the second argument is omitted, trims the characters ` ` (space), '\\t',\n'\\r', and '\\n'.\n\nReturns the right trimmed string."
		},
		"sprintf": {
			"kind": "function",
			"name": "module:core#sprintf",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"fmt": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "fmt",
					"description": "The format string."
				},
				"Arguments": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "Arguments",
					"description": "to be formatted."
				}
			},
			"subject": "Formats the given arguments according to the given format string.",
			"description": "Formats the given arguments according to the given format string.\n\nSee `printf()` for details.\n\nReturns the formatted string."
		},
		"printf": {
			"kind": "function",
			"name": "module:core#printf",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"fmt": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "fmt",
					"description": "The format string."
				},
				"Arguments": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "Arguments",
					"description": "to be formatted."
				}
			},
			"subject": "Formats the given arguments according to the given format string and outputs\nthe result to stdout.",
			"description": "Formats the given arguments according to the given format string and outputs\nthe result to stdout.\n\nUcode supports a restricted subset of the formats allowed by the underlying\nlibc's `printf()` implementation, namely it allows the `d`, `i`, `o`, `u`,\n`x`, `X`, `e`, `E`, `f`, `F`, `g`, `G`, `c` and `s` conversions.\n\nAdditionally, an ucode specific `J` format is implemented, which causes the\ncorresponding value to be formatted as JSON string. By prefixing the `J`\nformat letter with a precision specifier, the resulting JSON output will be\npretty printed. A precision of `0` will use tabs for indentation, any other\npositive precision will use that many spaces for indentation while a negative\nor omitted precision specifier will turn off pretty printing.\n\nOther format specifiers such as `n` or `z` are not accepted and returned\nverbatim. Format specifiers including `*` directives are rejected as well.\n\nReturns the number of bytes written to the standard output."
		},
		"require": {
			"kind": "function",
			"name": "module:core#require",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"name": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "name",
					"description": "The name of the module to require in dotted notation."
				}
			},
			"subject": "Load and evaluate ucode scripts or shared library extensions.",
			"description": "Load and evaluate ucode scripts or shared library extensions.\n\nThe `require()` function expands each member of the global\n`REQUIRE_SEARCH_PATH` array to a filesystem path by replacing the `*`\nplaceholder with a slash-separated version of the given dotted module name\nand subsequently tries to load a file at the resulting location.\n\nIf a file is found at one of the search path locations, it is compiled and\nevaluated or loaded via the C runtime's `dlopen()` function, depending on\nwhether the found file is a ucode script or a compiled dynamic library.\n\nThe resulting program function of the compiled/loaded module is then\nsubsequently executed with the current global environment, without a `this`\ncontext and without arguments.\n\nFinally, the return value of the invoked program function is returned back\nby `require()` to the caller.\n\nBy default, modules are cached in the global `modules` dictionary and\nsubsequent attempts to require the same module will return the cached module\ndictionary entry without re-evaluating the module.\n\nTo force reloading a module, the corresponding entry from the global\n`modules` dictionary can be deleted.\n\nTo preload a module or to provide a \"virtual\" module without a corresponding\nfilesystem resource, an entry can be manually added to the global `modules`\ndictionary.\n\nSummarized, the `require()` function can be roughly described by the\nfollowing code:\n\n```\nfunction require(name) {\nif (exists(modules, name))\nreturn modules[name];\n\nfor (const item in REQUIRE_SEARCH_PATH) {\nconst modpath = replace(item, '*', replace(name, '.', '/'));\nconst entryfunc = loadfile(modpath, { raw_mode: true });\n\nif (entryfunc) {\nconst modval = entryfunc();\nmodules[name] = modval;\n\nreturn modval;\n}\n}\n\ndie(`Module ${name} not found`);\n}\n```\n\nDue to the fact that `require()` is a runtime operation, module source code\nis only lazily evaluated/loaded upon invoking the first require invocation,\nwhich might lead to situations where errors in module sources are only\nreported much later throughout the program execution. Unless runtime loading\nof modules is absolutely required, e.g. to conditionally load extensions, the\ncompile time\n{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#named_import|`import` syntax}\nshould be preferred.\n\nReturns the module value (typically an object) on success.\n\nThrows an exception if the module function threw an exception.\n\nThrows an exception if no matching module could be found, if the module\ncontains syntax errors or upon other I/O related problems."
		},
		"iptoarr": {
			"kind": "function",
			"name": "module:core#iptoarr",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "number"
						}
					],
					"nullable": true
				}
			],
			"params": {
				"address": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "address",
					"description": "The IP address string to convert."
				}
			},
			"subject": "Convert the given IP address string to an array of byte values.",
			"description": "Convert the given IP address string to an array of byte values.\n\nIPv4 addresses result in arrays of 4 integers while IPv6 ones in arrays\ncontaining 16 integers. The resulting array can be turned back into IP\naddress strings using the inverse `arrtoip()` function.\n\nReturns an array containing the address byte values.\nReturns `null` if the given argument is not a string or an invalid IP."
		},
		"arrtoip": {
			"kind": "function",
			"name": "module:core#arrtoip",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"arr": {
					"type": [
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						}
					],
					"name": "arr",
					"description": "The byte array to convert into an IP address string."
				}
			},
			"subject": "Convert the given input array of byte values to an IP address string.",
			"description": "Convert the given input array of byte values to an IP address string.\n\nInput arrays of length 4 are converted to IPv4 addresses, arrays of length 16\nto IPv6 ones. All other lengths are rejected. If any array element is not an\ninteger or exceeds the range 0..255 (inclusive), the array is rejected.\n\nReturns a string containing the formatted IP address.\nReturns `null` if the input array was invalid."
		},
		"match": {
			"kind": "function",
			"name": "module:core#match",
			"return": [
				{
					"type": "array",
					"nullable": true
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The string to be matched against the pattern."
				},
				"pattern": {
					"type": [
						{
							"type": "RegExp"
						}
					],
					"name": "pattern",
					"description": "The regular expression pattern."
				}
			},
			"subject": "Match the given string against the regular expression pattern specified as\nthe second argument.",
			"description": "Match the given string against the regular expression pattern specified as\nthe second argument.\n\nIf the passed regular expression uses the `g` flag, the return value will be\nan array of arrays describing all found occurrences within the string.\n\nWithout the `g` modifier, an array describing the first match is returned.\n\nReturns `null` if the pattern was not found within the given string."
		},
		"replace": {
			"kind": "function",
			"name": "module:core#replace",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The string in which to replace occurrences."
				},
				"pattern": {
					"type": [
						{
							"type": "RegExp"
						},
						{
							"type": "string"
						}
					],
					"name": "pattern",
					"description": "The pattern to be replaced."
				},
				"replace": {
					"type": [
						{
							"type": "function"
						},
						{
							"type": "string"
						}
					],
					"name": "replace",
					"description": "The replacement value."
				},
				"limit": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[limit]",
					"description": "The optional limit of substitutions.",
					"optional": true
				}
			},
			"subject": "Replace occurrences of the specified pattern in the string passed as the\nfirst argument.",
			"description": "Replace occurrences of the specified pattern in the string passed as the\nfirst argument.\n\n- The pattern value may be either a regular expression or a plain string.\n- The replace value may be a function which is invoked for each found pattern\nor any other value which is converted into a plain string and used as\nreplacement.\n- When an optional limit is specified, substitutions are performed only that\nmany times.\n- If the pattern is a regular expression and not using the `g` flag, then\nonly the first occurrence in the string is replaced.\n- If the `g` flag is used or if the pattern is not a regular expression, all\noccurrences are replaced.\n- If the replace value is a callback function, it is invoked with the found\nsubstring as the first and any capture group values as subsequent\nparameters.\n- If the replace value is a string, specific substrings are substituted\nbefore it is inserted into the result.\n\nReturns a new string with the pattern replaced."
		},
		"json": {
			"kind": "function",
			"name": "module:core#json",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"str_or_resource": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str_or_resource",
					"description": "The string or resource object to be parsed as JSON."
				}
			},
			"subject": "Parse the given string or resource as JSON and return the resulting value.",
			"description": "Parse the given string or resource as JSON and return the resulting value.\n\nIf the input argument is a plain string, it is directly parsed as JSON.\n\nIf an array, object or resource value is given, this function will attempt to\ninvoke a `read()` method on it to read chunks of input text to incrementally\nparse as JSON data. Reading will stop if the object's `read()` method returns\neither `null` or an empty string.\n\nThrows an exception on parse errors, trailing garbage, or premature EOF.\n\nReturns the parsed JSON data."
		},
		"include": {
			"kind": "function",
			"name": "module:core#include",
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file to be included."
				},
				"scope": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[scope]",
					"description": "The optional scope object to override the execution scope.",
					"optional": true
				}
			},
			"subject": "Evaluate and include the file at the given path and optionally override the\nexecution scope with the given scope object.",
			"description": "Evaluate and include the file at the given path and optionally override the\nexecution scope with the given scope object.\n\nBy default, the file is executed within the same scope as the calling\n`include()`, but by passing an object as the second argument, it is possible\nto extend the scope available to the included file.\n\nThis is useful to supply additional properties as global variables to the\nincluded code. To sandbox included code, that is giving it only access to\nexplicitly provided properties, the `proto()` function can be used to create\na scope object with an empty prototype."
		},
		"render": {
			"kind": "function",
			"name": "module:core#render",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"path_or_func": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "function"
						}
					],
					"name": "path_or_func",
					"description": "The path to the file or the function to be rendered."
				},
				"scope_or_fnarg1": {
					"type": [
						{
							"type": "object"
						},
						{
							"type": "*"
						}
					],
					"name": "[scope_or_fnarg1]",
					"description": "The optional scope or the first argument for the function.",
					"optional": true
				},
				"fnarg2": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "[fnarg2]",
					"description": "The second argument for the function.",
					"optional": true
				},
				"fnargN": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[fnargN]",
					"description": "Additional arguments for the function.",
					"optional": true
				}
			},
			"subject": "When invoked with a string value as the first argument, the function acts\nlike `include()` but captures the output of the included file as a string and\nreturns the captured contents.",
			"description": "When invoked with a string value as the first argument, the function acts\nlike `include()` but captures the output of the included file as a string and\nreturns the captured contents.\n\nThe second argument is treated as the scope.\n\nWhen invoked with a function value as the first argument, `render()` calls\nthe given function and passes all subsequent arguments to it.\n\nAny output produced by the called function is captured and returned as a\nstring. The return value of the called function is discarded."
		},
		"warn": {
			"kind": "function",
			"name": "module:core#warn",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "x",
					"description": "The values to be printed."
				}
			},
			"subject": "Print any of the given values to stderr. Arrays and objects are converted to\ntheir JSON representation.",
			"description": "Print any of the given values to stderr. Arrays and objects are converted to\ntheir JSON representation.\n\nReturns the amount of bytes printed."
		},
		"system": {
			"kind": "function",
			"name": "module:core#system",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"command": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "array"
						}
					],
					"name": "command",
					"description": "The command to be executed."
				},
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout]",
					"description": "The optional timeout in milliseconds.",
					"optional": true
				}
			},
			"subject": "Executes the given command, waits for completion, and returns the resulting\nexit code.",
			"description": "Executes the given command, waits for completion, and returns the resulting\nexit code.\n\nThe command argument may be either a string, in which case it is passed to\n`/bin/sh -c`, or an array, which is directly converted into an `execv()`\nargument vector.\n\n- If the program terminated normally, a positive integer holding the\nprogram's `exit()` code is returned.\n- If the program was terminated by an uncaught signal, a negative signal\nnumber is returned.\n- If the optional timeout argument is specified, the program is terminated\nby `SIGKILL` after that many milliseconds if it doesn't complete within\nthe timeout.\n\nOmitting the timeout argument or passing `0` disables the command timeout.\n\nReturns the program exit code."
		},
		"trace": {
			"kind": "function",
			"name": "module:core#trace",
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "level",
					"description": "The level of tracing to enable."
				}
			},
			"subject": "Enables or disables VM opcode tracing.",
			"description": "Enables or disables VM opcode tracing.\n\nWhen invoked with a positive non-zero level, opcode tracing is enabled and\ndebug information is printed to stderr as the program is executed.\n\nInvoking `trace()` with zero as an argument turns off opcode tracing."
		},
		"proto": {
			"kind": "function",
			"name": "module:core#proto",
			"return": [
				{
					"type": "object",
					"nullable": true
				}
			],
			"params": {
				"val": {
					"type": [
						{
							"type": "array"
						},
						{
							"type": "object"
						}
					],
					"name": "val",
					"description": "The array or object value."
				},
				"proto": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[proto]",
					"description": "The optional prototype object.",
					"optional": true
				}
			},
			"subject": "Get or set the prototype of the array or object value `val`.",
			"description": "Get or set the prototype of the array or object value `val`.\n\nWhen invoked without a second argument, the function returns the current\nprototype of the value in `val` or `null` if there is no prototype or if the\ngiven value is neither an object nor an array.\n\nWhen invoked with a second prototype argument, the given `proto` value is set\nas the prototype on the array or object in `val`.\n\nThrows an exception if the given prototype value is not an object."
		},
		"sleep": {
			"kind": "function",
			"name": "module:core#sleep",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"milliseconds": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "milliseconds",
					"description": "The amount of milliseconds to sleep."
				}
			},
			"subject": "Pause execution for the given amount of milliseconds.",
			"description": "Pause execution for the given amount of milliseconds."
		},
		"assert": {
			"kind": "function",
			"name": "module:core#assert",
			"throws": [
				{
					"type": [
						{
							"type": "Error"
						}
					],
					"description": "When the condition is falsy."
				}
			],
			"params": {
				"cond": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "cond",
					"description": "The value to check for truthiness."
				},
				"message": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[message]",
					"description": "The message to include in the exception.",
					"optional": true
				}
			},
			"subject": "Raise an exception with the given message parameter when the value in `cond`\nis not truish.",
			"description": "Raise an exception with the given message parameter when the value in `cond`\nis not truish.\n\nWhen `message` is omitted, the default value is `Assertion failed`."
		},
		"regexp": {
			"kind": "function",
			"name": "module:core#regexp",
			"return": [
				{
					"type": "RegExp"
				}
			],
			"params": {
				"source": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "source",
					"description": "The pattern string."
				},
				"flags": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[flags]",
					"description": "The optional regular expression flags.",
					"optional": true
				}
			},
			"subject": "Construct a regular expression instance from the given `source` pattern\nstring and any flags optionally specified by the `flags` argument.",
			"description": "Construct a regular expression instance from the given `source` pattern\nstring and any flags optionally specified by the `flags` argument.\n\n- Throws a type error exception if `flags` is not a string or if the string\nin `flags` contains unrecognized regular expression flag characters.\n- Throws a syntax error when the pattern in `source` cannot be compiled into\na valid regular expression.\n\nReturns the compiled regular expression value."
		},
		"wildcard": {
			"kind": "function",
			"name": "module:core#wildcard",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"subject": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "subject",
					"description": "The subject to match against the wildcard pattern."
				},
				"pattern": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "pattern",
					"description": "The wildcard pattern."
				},
				"nocase": {
					"type": [
						{
							"type": "boolean"
						}
					],
					"name": "[nocase]",
					"description": "Whether to perform case-insensitive matching.",
					"optional": true
				}
			},
			"subject": "Match the given subject against the supplied wildcard (file glob) pattern.",
			"description": "Match the given subject against the supplied wildcard (file glob) pattern.\n\n- If a truthy value is supplied as the third argument, case-insensitive\nmatching is performed.\n- If a non-string value is supplied as the subject, it is converted into a\nstring before being matched.\n\nReturns `true` when the value matched the given pattern, otherwise `false`."
		},
		"sourcepath": {
			"kind": "function",
			"name": "module:core#sourcepath",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"depth": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[depth=0]",
					"description": "The depth to walk up the call stack.",
					"default": "0",
					"optional": true
				},
				"dironly": {
					"type": [
						{
							"type": "boolean"
						}
					],
					"name": "[dironly]",
					"description": "Whether to return only the directory portion of the source file path.",
					"optional": true
				}
			},
			"subject": "Determine the path of the source file currently being executed by ucode.",
			"description": "Determine the path of the source file currently being executed by ucode."
		},
		"min": {
			"kind": "function",
			"name": "module:core#min",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"val": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[val]",
					"description": "The values to compare.",
					"optional": true
				}
			},
			"subject": "Return the smallest value among all parameters passed to the function.",
			"description": "Return the smallest value among all parameters passed to the function."
		},
		"max": {
			"kind": "function",
			"name": "module:core#max",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"val": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[val]",
					"description": "The values to compare.",
					"optional": true
				}
			},
			"subject": "Return the largest value among all parameters passed to the function.",
			"description": "Return the largest value among all parameters passed to the function."
		},
		"b64dec": {
			"kind": "function",
			"name": "module:core#b64dec",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The base64 encoded string to decode."
				}
			},
			"subject": "Decodes the given base64 encoded string and returns the decoded result.",
			"description": "Decodes the given base64 encoded string and returns the decoded result.\n\n- If non-whitespace, non-base64 characters are encountered, if invalid\npadding or trailing garbage is found, the function returns `null`.\n- If a non-string argument is given, the function returns `null`."
		},
		"b64enc": {
			"kind": "function",
			"name": "module:core#b64enc",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"str": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str",
					"description": "The string to encode."
				}
			},
			"subject": "Encodes the given string into base64 and returns the resulting string.",
			"description": "Encodes the given string into base64 and returns the resulting string.\n\n- If a non-string argument is given, the function returns `null`."
		},
		"uniq": {
			"kind": "function",
			"name": "module:core#uniq",
			"return": [
				{
					"type": "array",
					"nullable": true
				}
			],
			"params": {
				"array": {
					"type": [
						{
							"type": "array"
						}
					],
					"name": "array",
					"description": "The input array."
				}
			},
			"subject": "Returns a new array containing all unique values of the given input array.",
			"description": "Returns a new array containing all unique values of the given input array.\n\n- The order is preserved, and subsequent duplicate values are skipped.\n- If a non-array argument is given, the function returns `null`."
		},
		"TimeSpec": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"sec": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "sec",
							"description": "Seconds (0..60)"
						},
						"min": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "min",
							"description": "Minutes (0..59)"
						},
						"hour": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "hour",
							"description": "Hours (0..23)"
						},
						"mday": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "mday",
							"description": "Day of month (1..31)"
						},
						"mon": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "mon",
							"description": "Month (1..12)"
						},
						"year": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "year",
							"description": "Year (>= 1900)"
						},
						"wday": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "wday",
							"description": "Day of week (1..7, Sunday = 7)"
						},
						"yday": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "yday",
							"description": "Day of year (1-366, Jan 1st = 1)"
						},
						"isdst": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "isdst",
							"description": "Daylight saving time in effect (yes = 1)"
						}
					}
				}
			],
			"name": "module:core.TimeSpec",
			"subject": "A time spec is a plain object describing a point in time, it is returned by\nthe {@link module:core#gmtime|gmtime()} and\n{@link module:core#localtime|localtime()} functions and expected as parameter\nby the complementary {@link module:core#timegm|timegm()} and\n{@link module:core#timelocal|timelocal()} functions.",
			"description": "A time spec is a plain object describing a point in time, it is returned by\nthe {@link module:core#gmtime|gmtime()} and\n{@link module:core#localtime|localtime()} functions and expected as parameter\nby the complementary {@link module:core#timegm|timegm()} and\n{@link module:core#timelocal|timelocal()} functions.\n\nWhen returned by `gmtime()` or `localtime()`, all members of the object will\nbe initialized, when passed as argument to `timegm()` or `timelocal()`, most\nmember values are optional."
		},
		"localtime": {
			"kind": "function",
			"name": "module:core#localtime",
			"return": [
				{
					"type": "module:core.TimeSpec"
				}
			],
			"params": {
				"epoch": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[epoch]",
					"description": "The epoch timestamp.",
					"optional": true
				}
			},
			"subject": "Return the given epoch timestamp (or now, if omitted) as a dictionary\ncontaining broken-down date and time information according to the local\nsystem timezone.",
			"description": "Return the given epoch timestamp (or now, if omitted) as a dictionary\ncontaining broken-down date and time information according to the local\nsystem timezone.\n\nSee {@link module:core.TimeSpec|TimeSpec} for a description of the fields.\n\nNote that in contrast to the underlying `localtime(3)` C library function,\nthe values for `mon`, `wday`, and `yday` are 1-based, and the `year` is\n1900-based."
		},
		"gmtime": {
			"kind": "function",
			"name": "module:core#gmtime",
			"return": [
				{
					"type": "module:core.TimeSpec"
				}
			],
			"params": {
				"epoch": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[epoch]",
					"description": "The epoch timestamp.",
					"optional": true
				}
			},
			"subject": "Like `localtime()` but interpreting the given epoch value as UTC time.",
			"description": "Like `localtime()` but interpreting the given epoch value as UTC time.\n\nSee {@link module:core#localtime|localtime()} for details on the return value."
		},
		"timelocal": {
			"kind": "function",
			"name": "module:core#timelocal",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"datetimespec": {
					"type": [
						{
							"type": "module:core.TimeSpec"
						}
					],
					"name": "datetimespec",
					"description": "The broken-down date and time dictionary."
				}
			},
			"subject": "Performs the inverse operation of {@link module:core#localtime|localtime()}\nby taking a broken-down date and time dictionary and transforming it into an\nepoch value according to the local system timezone.",
			"description": "Performs the inverse operation of {@link module:core#localtime|localtime()}\nby taking a broken-down date and time dictionary and transforming it into an\nepoch value according to the local system timezone.\n\nThe `wday` and `yday` fields of the given date time specification are\nignored. Field values outside of their valid range are internally normalized,\ne.g. October 40th is interpreted as November 9th.\n\nReturns the resulting epoch value or null if the input date time dictionary\nwas invalid or if the date time specification cannot be represented as epoch\nvalue."
		},
		"timegm": {
			"kind": "function",
			"name": "module:core#timegm",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"datetimespec": {
					"type": [
						{
							"type": "module:core.TimeSpec"
						}
					],
					"name": "datetimespec",
					"description": "The broken-down date and time dictionary."
				}
			},
			"subject": "Like `timelocal()` but interpreting the given date time specification as UTC\ntime.",
			"description": "Like `timelocal()` but interpreting the given date time specification as UTC\ntime.\n\nSee {@link module:core#timelocal|timelocal()} for details."
		},
		"clock": {
			"kind": "function",
			"name": "module:core#clock",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "number"
						}
					],
					"nullable": true
				}
			],
			"params": {
				"monotonic": {
					"type": [
						{
							"type": "boolean"
						}
					],
					"name": "[monotonic]",
					"description": "Whether to query the monotonic system clock.",
					"optional": true
				}
			},
			"subject": "Reads the current second and microsecond value of the system clock.",
			"description": "Reads the current second and microsecond value of the system clock.\n\nBy default, the realtime clock is queried which might skew forwards or\nbackwards due to NTP changes, system sleep modes etc. If a truish value is\npassed as argument, the monotonic system clock is queried instead, which will\nreturn the monotonically increasing time since some arbitrary point in the\npast (usually the system boot time).\n\nReturns a two element array containing the full seconds as the first element\nand the nanosecond fraction as the second element.\n\nReturns `null` if a monotonic clock value is requested and the system does\nnot implement this clock type."
		},
		"hexenc": {
			"kind": "function",
			"name": "module:core#hexenc",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"val": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "val",
					"description": "The byte string to encode."
				}
			},
			"subject": "Encodes the given byte string into a hexadecimal digit string, converting\nthe input value to a string if needed.",
			"description": "Encodes the given byte string into a hexadecimal digit string, converting\nthe input value to a string if needed."
		},
		"hexdec": {
			"kind": "function",
			"name": "module:core#hexdec",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"hexstring": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "hexstring",
					"description": "The hexadecimal digit string to decode."
				},
				"skipchars": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[skipchars]",
					"description": "The characters to skip during decoding.",
					"optional": true
				}
			},
			"subject": "Decodes the given hexadecimal digit string into a byte string, optionally\nskipping specified characters.",
			"description": "Decodes the given hexadecimal digit string into a byte string, optionally\nskipping specified characters.\n\nIf the characters to skip are not specified, a default of `\" \\t\\n\"` is used.\n\nReturns null if the input string contains invalid characters or an uneven\namount of hex digits.\n\nReturns the decoded byte string on success."
		},
		"gc": {
			"kind": "function",
			"name": "module:core#gc",
			"return": [
				{
					"type": "(boolean|number)",
					"nullable": true
				}
			],
			"params": {
				"operation": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[operation]",
					"description": "The operation to perform.",
					"optional": true
				},
				"argument": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "[argument]",
					"description": "The argument for the operation.",
					"optional": true
				}
			},
			"subject": "Interacts with the mark and sweep garbage collector of the running ucode\nvirtual machine.",
			"description": "Interacts with the mark and sweep garbage collector of the running ucode\nvirtual machine.\n\nDepending on the given `operation` string argument, the meaning of `argument`\nand the function return value differs.\n\nThe following operations are defined:\n\n- `collect` - Perform a complete garbage collection cycle, returns `true`.\n- `start` - (Re-)start periodic garbage collection, `argument` is an optional\ninteger in the range `1..65535` specifying the interval.\nDefaults to `1000` if omitted. Returns `true` if the periodic GC\nwas previously stopped and is now started or if the interval\nchanged. Returns `false` otherwise.\n- `stop` - Stop periodic garbage collection. Returns `true` if the periodic\nGC was previously started and is now stopped, `false` otherwise.\n- `count` - Count the amount of active complex object references in the VM\ncontext, returns the counted amount.\n\nIf the `operation` argument is omitted, the default is `collect`."
		},
		"ParseConfig": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"lstrip_blocks": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "lstrip_blocks",
							"description": "Whether to strip whitespace preceding template directives.\nSee {@link tutorial-02-syntax.html#whitespace-handling|Whitespace handling}."
						},
						"trim_blocks": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "trim_blocks",
							"description": "Whether to trim trailing newlines following template directives.\nSee {@link tutorial-02-syntax.html#whitespace-handling|Whitespace handling}."
						},
						"strict_declarations": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "strict_declarations",
							"description": "Whether to compile the code in strict mode (`true`) or not (`false`)."
						},
						"raw_mode": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "raw_mode",
							"description": "Whether to compile the code in plain script mode (`true`) or not (`false`)."
						},
						"module_search_path": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "string"
										}
									]
								}
							],
							"name": "module_search_path",
							"description": "Override the module search path for compile time imports while compiling the\nucode source."
						},
						"force_dynlink_list": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "string"
										}
									]
								}
							],
							"name": "force_dynlink_list",
							"description": "List of module names assumed to be dynamic library extensions, allows\ncompiling ucode source with import statements referring to `*.so` extensions\nnot present at compile time."
						}
					}
				}
			],
			"name": "module:core.ParseConfig",
			"subject": "A parse configuration is a plain object describing options to use when\ncompiling ucode at runtime. It is expected as parameter by the\n{@link module:core#loadfile|loadfile()} and\n{@link module:core#loadstring|loadstring()} functions.",
			"description": "A parse configuration is a plain object describing options to use when\ncompiling ucode at runtime. It is expected as parameter by the\n{@link module:core#loadfile|loadfile()} and\n{@link module:core#loadstring|loadstring()} functions.\n\nAll members of the parse configuration object are optional and will default\nto the state of the running ucode file if omitted."
		},
		"loadstring": {
			"kind": "function",
			"name": "module:core#loadstring",
			"return": [
				{
					"type": "function"
				}
			],
			"params": {
				"code": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "code",
					"description": "The code string to compile."
				},
				"options": {
					"type": [
						{
							"type": "module:core.ParseConfig"
						}
					],
					"name": "[options]",
					"description": "The options for compilation.",
					"optional": true
				}
			},
			"subject": "Compiles the given code string into a ucode program and returns the resulting\nprogram entry function.",
			"description": "Compiles the given code string into a ucode program and returns the resulting\nprogram entry function.\n\nThe optional `options` dictionary overrides parse and compile options.\n\n- If a non-string `code` argument is given, it is implicitly converted to a\nstring value first.\n- If `options` is omitted or a non-object value, the compile options of the\nrunning ucode program are reused.\n\nSee {@link module:core.ParseConfig|ParseConfig} for known keys within the\n`options` object. Unrecognized keys are ignored, unspecified options default\nto those of the running program.\n\nReturns the compiled program entry function.\n\nThrows an exception on compilation errors."
		},
		"loadfile": {
			"kind": "function",
			"name": "module:core#loadfile",
			"return": [
				{
					"type": "function"
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path of the file to compile."
				},
				"options": {
					"type": [
						{
							"type": "module:core.ParseConfig"
						}
					],
					"name": "[options]",
					"description": "The options for compilation.",
					"optional": true
				}
			},
			"subject": "Compiles the given file into a ucode program and returns the resulting\nprogram entry function.",
			"description": "Compiles the given file into a ucode program and returns the resulting\nprogram entry function.\n\nSee {@link module:core#loadstring|`loadstring()`} for details.\n\nReturns the compiled program entry function.\n\nThrows an exception on compilation or file I/O errors."
		},
		"call": {
			"kind": "function",
			"name": "module:core#call",
			"return": [
				{
					"type": "*"
				}
			],
			"params": {
				"fn": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "fn",
					"description": "Function value to call."
				},
				"ctx": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "[ctx=null]",
					"description": "`this` context for the invoked function.",
					"default": "null",
					"optional": true
				},
				"scope": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[scope=null]",
					"description": "Global environment for the invoked function.",
					"default": "null",
					"optional": true
				},
				"arg": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[arg]",
					"description": "Additional arguments to pass to the invoked function.",
					"optional": true
				}
			},
			"subject": "Calls the given function value with a modified environment.",
			"description": "Calls the given function value with a modified environment.\n\nThe given `ctx` argument is used as `this` context for the invoked function\nand the given `scope` value as global environment. Any further arguments are\npassed to the invoked function as-is.\n\nWhen `ctx` is omitted or `null`, the function will get invoked with `this`\nbeing `null`.\n\nWhen `scope` is omitted or `null`, the function will get executed with the\ncurrent global environment of the running program. When `scope` is set to a\ndictionary, the dictionary is used as global function environment.\n\nWhen the `scope` dictionary has no prototype, the current global environment\nwill be set as prototype, means the scope will inherit from it.\n\nWhen a scope prototype is set, it is kept. This allows passing an isolated\n(sandboxed) function scope without access to the global environment.\n\nAny further argument is forwarded as-is to the invoked function as function\ncall argument.\n\nReturns `null` if the given function value `fn` is not callable.\n\nReturns the return value of the invoked function in all other cases.\n\nForwards exceptions thrown by the invoked function."
		},
		"signal": {
			"kind": "function",
			"name": "module:core#signal",
			"return": [
				{
					"type": "function"
				},
				{
					"type": "string"
				}
			],
			"params": {
				"signal": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "signal",
					"description": "The signal to query/set handler for."
				},
				"handler": {
					"type": [
						{
							"type": "function"
						},
						{
							"type": "string"
						}
					],
					"name": "[handler]",
					"description": "The signal handler to install for the given signal.",
					"optional": true
				}
			},
			"subject": "Set or query process signal handler function.",
			"description": "Set or query process signal handler function.\n\nWhen invoked with two arguments, a signal specification and a signal handler\nvalue, this function configures a new process signal handler.\n\nWhen invoked with one argument, a signal specification, this function returns\nthe currently configured handler for the given signal.\n\nThe signal specification might either be an integer signal number or a string\nvalue containing a signal name (with or without \"SIG\" prefix). Signal names\nare treated case-insensitively.\n\nThe signal handler might be either a callable function value or one of the\ntwo special string values `\"ignore\"` and `\"default\"`. Passing `\"ignore\"` will\nmask the given process signal while `\"default\"` will restore the operating\nsystems default behaviour for the given signal.\n\nIn case a callable handler function is provided, it is invoked at the\nearliest  opportunity after receiving the corresponding signal from the\noperating system. The invoked function will receive a single argument, the\nnumber of the signal it is invoked for.\n\nNote that within the ucode VM, process signals are not immediately delivered,\ninstead the VM keeps track of received signals and delivers them to the ucode\nscript environment at the next opportunity, usually before executing the next\nbyte code instruction. This means that if a signal is received while\nperforming a computationally expensive operation in C mode, such as a complex\nregexp match, the corresponding ucode signal handler will only be invoked\nafter that operation concluded and control flow returns to the VM.\n\nReturns the signal handler function or one of the special values `\"ignore\"`\nor `\"default\"` corresponding to the given signal specification.\n\nReturns `null` if an invalid signal spec or signal handler was provided.\n\nReturns `null` if changing the signal action failed, e.g. due to insufficient\npermission, or when attempting to ignore a non-ignorable signal."
		}
	},
	"debug": {
		"memdump": {
			"kind": "function",
			"name": "module:debug#memdump",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"file": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "module:fs.file"
						},
						{
							"type": "module:fs.proc"
						}
					],
					"name": "file",
					"description": "The file path or open file handle to write report to."
				}
			},
			"subject": "Write a memory dump report to the given file.",
			"description": "Write a memory dump report to the given file.\n\nThis function generates a human readable memory dump of ucode values\ncurrently managed by the running VM which is useful to track down logical\nmemory leaks in scripts.\n\nThe file parameter can be either a string value containing a file path, in\nwhich case this function tries to create and write the report file at the\ngiven location, or an already open file handle this function should write to.\n\nReturns `true` if the report has been written.\n\nReturns `null` if the file could not be opened or if the handle was invalid."
		},
		"traceback": {
			"kind": "function",
			"name": "module:debug#traceback",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "module:debug.StackTraceEntry"
						}
					]
				}
			],
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[level=1]",
					"description": "The number of callframes up the call trace should start, `0` is this function\nitself, `1` the function calling it and so on.",
					"default": "1",
					"optional": true
				}
			},
			"subject": "Capture call stack trace.",
			"description": "Capture call stack trace.\n\nThis function captures the current call stack and returns it. The optional\nlevel parameter controls how many calls up the trace should start. It\ndefaults to `1`, that is the function calling this `traceback()` function.\n\nReturns an array of stack trace entries describing the function invocations\nup to the point where `traceback()` is called."
		},
		"StackTraceEntry": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"callee": {
							"type": [
								{
									"type": "function"
								}
							],
							"name": "callee",
							"description": "The function that was called."
						},
						"this": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "this",
							"description": "The `this` context the function was called with."
						},
						"mcall": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "mcall",
							"description": "Indicates whether the function was invoked as a method."
						},
						"strict": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[strict]",
							"description": "Indicates whether the VM was running in strict mode when the function was\ncalled (only applicable to non-C, pure ucode calls)."
						},
						"filename": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[filename]",
							"description": "The name of the source file that called the function (only applicable to\nnon-C, pure ucode calls)."
						},
						"line": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[line]",
							"description": "The source line of the function call (only applicable to non-C, pure ucode\ncalls)."
						},
						"byte": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[byte]",
							"description": "The source line offset of the function call (only applicable to non-C, pure\nucode calls)."
						},
						"context": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[context]",
							"description": "The surrounding source code context formatted as human-readable string,\nuseful for generating debug messages (only applicable to non-C, pure ucode\ncalls)."
						}
					}
				}
			],
			"name": "module:debug.StackTraceEntry",
			"optional": true,
			"description": ""
		},
		"sourcepos": {
			"kind": "function",
			"name": "module:debug#sourcepos",
			"return": [
				{
					"type": "module:debug.SourcePosition",
					"nullable": true
				}
			],
			"subject": "Obtain information about the current source position.",
			"description": "Obtain information about the current source position.\n\nThe `sourcepos()` function determines the source code position of the\ncurrent instruction invoking this function.\n\nReturns a dictionary containing the filename, line number and line byte\noffset of the call site.\n\nReturns `null` if this function was invoked from C code."
		},
		"SourcePosition": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"filename": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "filename",
							"description": "The name of the source file that called this function."
						},
						"line": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "line",
							"description": "The source line of the function call."
						},
						"byte": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "byte",
							"description": "The source line offset of the function call."
						}
					}
				}
			],
			"name": "module:debug.SourcePosition",
			"description": ""
		},
		"UpvalRef": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"name": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "name",
							"description": "The name of the captured variable."
						},
						"closed": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "closed",
							"description": "Indicates whether the captured variable (upvalue) is closed or not. A closed\nupvalue means that the function value outlived the declaration scope of the\ncaptured variable."
						},
						"value": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "value",
							"description": "The current value of the captured variable."
						},
						"slot": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[slot]",
							"description": "The stack slot of the captured variable. Only applicable to open (non-closed)\ncaptured variables."
						}
					}
				}
			],
			"name": "module:debug.UpvalRef",
			"optional": true,
			"description": ""
		},
		"getinfo": {
			"kind": "function",
			"name": "module:debug#getinfo",
			"return": [
				{
					"type": "module:debug.ValueInformation",
					"nullable": true
				}
			],
			"params": {
				"value": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "value",
					"description": "The value to query information for."
				}
			},
			"subject": "Obtain information about the given value.",
			"description": "Obtain information about the given value.\n\nThe `getinfo()` function allows querying internal information about the\ngiven ucode value, such as the current reference count, the mark bit state\netc.\n\nReturns a dictionary with value type specific details.\n\nReturns `null` if a `null` value was provided."
		},
		"ValueInformation": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"type": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "type",
							"description": "The name of the value type, one of `integer`, `boolean`, `string`, `double`,\n`array`, `object`, `regexp`, `cfunction`, `closure`, `upvalue` or `resource`."
						},
						"value": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "value",
							"description": "The value itself."
						},
						"tagged": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "tagged",
							"description": "Indicates whether the given value is internally stored as tagged pointer\nwithout an additional heap allocation."
						},
						"mark": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[mark]",
							"description": "Indicates whether the value has it's mark bit set, which is used for loop\ndetection during recursive object traversal on garbage collection cycles or\ncomplex value stringification. Only applicable to non-tagged values."
						},
						"refcount": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[refcount]",
							"description": "The current reference count of the value. Note that the `getinfo()` function\nplaces a reference to the value into the `value` field of the resulting\ninformation dictionary, so the ref count will always be at least 2 - one\nreference for the function call argument and one for the value property in\nthe result dictionary. Only applicable to non-tagged values."
						},
						"unsigned": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[unsigned]",
							"description": "Whether the number value is internally stored as unsigned integer. Only\napplicable to non-tagged integer values."
						},
						"address": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[address]",
							"description": "The address of the underlying C heap memory. Only applicable to non-tagged\n`string`, `array`, `object`, `cfunction` or `resource` values."
						},
						"length": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[length]",
							"description": "The length of the underlying string memory. Only applicable to non-tagged\n`string` values."
						},
						"count": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[count]",
							"description": "The amount of elements in the underlying memory structure. Only applicable to\n`array` and `object` values."
						},
						"constant": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[constant]",
							"description": "Indicates whether the value is constant (immutable). Only applicable to\n`array` and `object` values."
						},
						"prototype": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "[prototype]",
							"description": "The associated prototype value, if any. Only applicable to `array`, `object`\nand `prototype` values."
						},
						"source": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[source]",
							"description": "The original regex source pattern. Only applicable to `regexp` values."
						},
						"icase": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[icase]",
							"description": "Whether the compiled regex has the `i` (ignore case) flag set. Only\napplicable to `regexp` values."
						},
						"global": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[global]",
							"description": "Whether the compiled regex has the `g` (global) flag set. Only applicable to\n`regexp` values."
						},
						"newline": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[newline]",
							"description": "Whether the compiled regex has the `s` (single line) flag set. Only\napplicable to `regexp` values."
						},
						"nsub": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[nsub]",
							"description": "The amount of capture groups within the regular expression. Only applicable\nto `regexp` values."
						},
						"name": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[name]",
							"description": "The name of the non-anonymous function. Only applicable to `cfunction` and\n`closure` values. Set to `null` for anonymous function values."
						},
						"arrow": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[arrow]",
							"description": "Indicates whether the ucode function value is an arrow function. Only\napplicable to `closure` values."
						},
						"module": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[module]",
							"description": "Indicates whether the ucode function value is a module entry point. Only\napplicable to `closure` values."
						},
						"strict": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[strict]",
							"description": "Indicates whether the function body will be executed in strict mode. Only\napplicable to `closure` values."
						},
						"vararg": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "[vararg]",
							"description": "Indicates whether the ucode function takes a variable number of arguments.\nOnly applicable to `closure` values."
						},
						"nargs": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[nargs]",
							"description": "The number of arguments expected by the ucode function, excluding a potential\nfinal variable argument ellipsis. Only applicable to `closure` values."
						},
						"argnames": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "string"
										}
									]
								}
							],
							"name": "[argnames]",
							"description": "The names of the function arguments in their declaration order. Only\napplicable to `closure` values."
						},
						"nupvals": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[nupvals]",
							"description": "The number of upvalues associated with the ucode function. Only applicable to\n`closure` values."
						},
						"upvals": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "module:debug.UpvalRef"
										}
									]
								}
							],
							"name": "[upvals]",
							"description": "An array of upvalue information objects. Only applicable to `closure` values."
						},
						"filename": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[filename]",
							"description": "The path of the source file the function was declared in. Only applicable to\n`closure` values."
						},
						"line": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[line]",
							"description": "The source line number the function was declared at. Only applicable to\n`closure` values."
						},
						"byte": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[byte]",
							"description": "The source line offset the function was declared at. Only applicable to\n`closure` values."
						}
					}
				}
			],
			"name": "module:debug.ValueInformation",
			"optional": true,
			"description": ""
		},
		"LocalInfo": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"index": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "index",
							"description": "The index of the local variable."
						},
						"name": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "name",
							"description": "The name of the local variable."
						},
						"value": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "value",
							"description": "The current value of the local variable."
						},
						"linefrom": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "linefrom",
							"description": "The source line number of the local variable declaration."
						},
						"bytefrom": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "bytefrom",
							"description": "The source line offset of the local variable declaration."
						},
						"lineto": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "lineto",
							"description": "The source line number where the local variable goes out of scope."
						},
						"byteto": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "byteto",
							"description": "The source line offset where the local vatiable goes out of scope."
						}
					}
				}
			],
			"name": "module:debug.LocalInfo",
			"description": ""
		},
		"getlocal": {
			"kind": "function",
			"name": "module:debug#getlocal",
			"return": [
				{
					"type": "module:debug.LocalInfo",
					"nullable": true
				}
			],
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[level=1]",
					"description": "The amount of call stack levels up local variables should be queried.",
					"default": "1",
					"optional": true
				},
				"variable": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "variable",
					"description": "The variable index or variable name to obtain information for."
				}
			},
			"subject": "Obtain local variable.",
			"description": "Obtain local variable.\n\nThe `getlocal()` function retrieves information about the specified local\nvariable at the given call stack depth.\n\nThe call stack depth specifies the amount of levels up local variables should\nbe queried. A value of `0` refers to this `getlocal()` function call itself,\n`1` to the function calling `getlocal()` and so on.\n\nThe variable to query might be either specified by name or by its index with\nindex numbers following the source code declaration order.\n\nReturns a dictionary holding information about the given variable.\n\nReturns `null` if the stack depth exceeds the size of the current call stack.\n\nReturns `null` if the invocation at the given stack depth is a C call.\n\nReturns `null` if the given variable name is not found or the given variable\nindex is invalid."
		},
		"setlocal": {
			"kind": "function",
			"name": "module:debug#setlocal",
			"return": [
				{
					"type": "module:debug.LocalInfo",
					"nullable": true
				}
			],
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[level=1]",
					"description": "The amount of call stack levels up local variables should be updated.",
					"default": "1",
					"optional": true
				},
				"variable": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "variable",
					"description": "The variable index or variable name to update."
				},
				"value": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "[value=null]",
					"description": "The value to set the local variable to.",
					"default": "null",
					"optional": true
				}
			},
			"subject": "Set local variable.",
			"description": "Set local variable.\n\nThe `setlocal()` function manipulates the value of the specified local\nvariable at the given call stack depth.\n\nThe call stack depth specifies the amount of levels up local variables should\nbe updated. A value of `0` refers to this `setlocal()` function call itself,\n`1` to the function calling `setlocal()` and so on.\n\nThe variable to update might be either specified by name or by its index with\nindex numbers following the source code declaration order.\n\nReturns a dictionary holding information about the updated variable.\n\nReturns `null` if the stack depth exceeds the size of the current call stack.\n\nReturns `null` if the invocation at the given stack depth is a C call.\n\nReturns `null` if the given variable name is not found or the given variable\nindex is invalid."
		},
		"UpvalInfo": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"index": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "index",
							"description": "The index of the captured variable (upvalue)."
						},
						"name": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "name",
							"description": "The name of the captured variable."
						},
						"closed": {
							"type": [
								{
									"type": "boolean"
								}
							],
							"name": "closed",
							"description": "Indicates whether the captured variable is closed or not. A closed upvalue\nmeans that the function outlived the declaration scope of the captured\nvariable."
						},
						"value": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "value",
							"description": "The current value of the captured variable."
						}
					}
				}
			],
			"name": "module:debug.UpvalInfo",
			"description": ""
		},
		"getupval": {
			"kind": "function",
			"name": "module:debug#getupval",
			"return": [
				{
					"type": "module:debug.UpvalInfo",
					"nullable": true
				}
			],
			"params": {
				"target": {
					"type": [
						{
							"type": "function"
						},
						{
							"type": "number"
						}
					],
					"name": "target",
					"description": "Either a function value referring to a closure to query upvalues for or a\nstack depth number selecting a closure that many levels up."
				},
				"variable": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "variable",
					"description": "The variable index or variable name to obtain information for."
				}
			},
			"subject": "Obtain captured variable (upvalue).",
			"description": "Obtain captured variable (upvalue).\n\nThe `getupval()` function retrieves information about the specified captured\nvariable associated with the given function value or the invoked function at\nthe given call stack depth.\n\nThe call stack depth specifies the amount of levels up the function should be\nselected to query associated captured variables for. A value of `0` refers to\nthis `getupval()` function call itself, `1` to the function calling\n`getupval()` and so on.\n\nThe variable to query might be either specified by name or by its index with\nindex numbers following the source code declaration order.\n\nReturns a dictionary holding information about the given variable.\n\nReturns `null` if the given function value is not a closure.\n\nReturns `null` if the stack depth exceeds the size of the current call stack.\n\nReturns `null` if the invocation at the given stack depth is not a closure.\n\nReturns `null` if the given variable name is not found or the given variable\nindex is invalid."
		},
		"setupval": {
			"kind": "function",
			"name": "module:debug#setupval",
			"return": [
				{
					"type": "module:debug.UpvalInfo",
					"nullable": true
				}
			],
			"params": {
				"target": {
					"type": [
						{
							"type": "function"
						},
						{
							"type": "number"
						}
					],
					"name": "target",
					"description": "Either a function value referring to a closure to update upvalues for or a\nstack depth number selecting a closure that many levels up."
				},
				"variable": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "variable",
					"description": "The variable index or variable name to update."
				},
				"value": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "value",
					"description": "The value to set the variable to."
				}
			},
			"subject": "Set upvalue.",
			"description": "Set upvalue.\n\nThe `setupval()` function manipulates the value of the specified captured\nvariable associated with the given function value or the invoked function at\nthe given call stack depth.\n\nThe call stack depth specifies the amount of levels up the function should be\nselected to update associated captured variables for. A value of `0` refers\nto this `setupval()` function call itself, `1` to the function calling\n`setupval()` and so on.\n\nThe variable to update might be either specified by name or by its index with\nindex numbers following the source code declaration order.\n\nReturns a dictionary holding information about the updated variable.\n\nReturns `null` if the given function value is not a closure.\n\nReturns `null` if the stack depth exceeds the size of the current call stack.\n\nReturns `null` if the invocation at the given stack depth is not a closure.\n\nReturns `null` if the given variable name is not found or the given variable\nindex is invalid."
		}
	},
	"fs": {
		"error": {
			"kind": "function",
			"name": "module:fs#error",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"subject": "Query error information.",
			"description": "Query error information.\n\nReturns a string containing a description of the last occurred error or\n`null` if there is no error information."
		},
		"popen": {
			"kind": "function",
			"name": "module:fs#popen",
			"return": [
				{
					"type": "module:fs.proc",
					"nullable": true
				}
			],
			"params": {
				"command": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "command",
					"description": "The command to be executed."
				},
				"mode": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[mode=\"r\"]",
					"description": "The open mode of the process handle.",
					"default": "\"r\"",
					"optional": true
				}
			},
			"subject": "Starts a process and returns a handle representing the executed process.",
			"description": "Starts a process and returns a handle representing the executed process.\n\nThe handle will be connected to the process stdin or stdout, depending on the\nvalue of the mode argument.\n\nThe mode argument may be either \"r\" to open the process for reading (connect\nto its stdin) or \"w\" to open the process for writing (connect to its stdout).\n\nThe mode character \"r\" or \"w\" may be optionally followed by \"e\" to apply the\nFD_CLOEXEC flag onto the open descriptor.\n\nReturns a process handle referring to the executed process.\n\nReturns `null` if an error occurred."
		},
		"open": {
			"kind": "function",
			"name": "module:fs#open",
			"return": [
				{
					"type": "module:fs.file",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file."
				},
				"mode": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[mode=\"r\"]",
					"description": "The file opening mode.",
					"default": "\"r\"",
					"optional": true
				},
				"perm": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[perm=0o666]",
					"description": "The file creation permissions (for modes `w…` and `a…`)",
					"default": "0o666",
					"optional": true
				}
			},
			"subject": "Opens a file.",
			"description": "Opens a file.\n\nThe mode argument specifies the way the file is opened, it may\nstart with one of the following values:\n\n| Mode    | Description                                                                                                   |\n|---------|---------------------------------------------------------------------------------------------------------------|\n| \"r\"     | Opens a file for reading. The file must exist.                                                                 |\n| \"w\"     | Opens a file for writing. If the file exists, it is truncated. If the file does not exist, it is created.     |\n| \"a\"     | Opens a file for appending. Data is written at the end of the file. If the file does not exist, it is created. |\n| \"r+\"    | Opens a file for both reading and writing. The file must exist.                                              |\n| \"w+\"    | Opens a file for both reading and writing. If the file exists, it is truncated. If the file does not exist, it is created. |\n| \"a+\"    | Opens a file for both reading and appending. Data can be read and written at the end of the file. If the file does not exist, it is created. |\n\nAdditionally, the following flag characters may be appended to\nthe mode value:\n\n| Flag    | Description                                                                                                   |\n|---------|---------------------------------------------------------------------------------------------------------------|\n| \"x\"     | Opens a file for exclusive creation. If the file exists, the `open` call fails.                             |\n| \"e\"     | Opens a file with the `O_CLOEXEC` flag set, ensuring that the file descriptor is closed on `exec` calls.      |\n\nIf the mode is one of `\"w…\"` or `\"a…\"`, the permission argument\ncontrols the filesystem permissions bits used when creating\nthe file.\n\nReturns a file handle object associated with the opened file."
		},
		"fdopen": {
			"kind": "function",
			"name": "module:fs#fdopen",
			"return": [
				{
					"type": "object"
				}
			],
			"params": {
				"fd": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "fd",
					"description": "The file descriptor."
				},
				"mode": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[mode=\"r\"]",
					"description": "The open mode.",
					"default": "\"r\"",
					"optional": true
				}
			},
			"subject": "Associates a file descriptor number with a file handle object.",
			"description": "Associates a file descriptor number with a file handle object.\n\nThe mode argument controls how the file handle object is opened\nand must match the open mode of the underlying descriptor.\n\nIt may be set to one of the following values:\n\n| Mode    | Description                                                                                                  |\n|---------|--------------------------------------------------------------------------------------------------------------|\n| \"r\"     | Opens a file stream for reading. The file descriptor must be valid and opened in read mode.                  |\n| \"w\"     | Opens a file stream for writing. The file descriptor must be valid and opened in write mode.                 |\n| \"a\"     | Opens a file stream for appending. The file descriptor must be valid and opened in write mode.               |\n| \"r+\"    | Opens a file stream for both reading and writing. The file descriptor must be valid and opened in read/write mode. |\n| \"w+\"    | Opens a file stream for both reading and writing. The file descriptor must be valid and opened in read/write mode. |\n| \"a+\"    | Opens a file stream for both reading and appending. The file descriptor must be valid and opened in read/write mode. |\n\nReturns the file handle object associated with the file descriptor."
		},
		"opendir": {
			"kind": "function",
			"name": "module:fs#opendir",
			"return": [
				{
					"type": "module:fs.dir",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the directory."
				}
			},
			"subject": "Opens a directory and returns a directory handle associated with the open\ndirectory descriptor.",
			"description": "Opens a directory and returns a directory handle associated with the open\ndirectory descriptor.\n\nReturns a director handle referring to the open directory.\n\nReturns `null` if an error occurred."
		},
		"readlink": {
			"kind": "function",
			"name": "module:fs#readlink",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the symbolic link."
				}
			},
			"subject": "Reads the target path of a symbolic link.",
			"description": "Reads the target path of a symbolic link.\n\nReturns a string containing the target path.\n\nReturns `null` if an error occurred."
		},
		"FileStatResult": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"dev": {
							"type": [
								{
									"type": "object",
									"properties": {
										"major": {
											"type": [
												{
													"type": "number"
												}
											],
											"name": "dev.major",
											"description": "The major device number."
										},
										"minor": {
											"type": [
												{
													"type": "number"
												}
											],
											"name": "dev.minor",
											"description": "The minor device number."
										}
									}
								}
							],
							"name": "dev",
							"description": "The device information."
						},
						"perm": {
							"type": [
								{
									"type": "object",
									"properties": {
										"setuid": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.setuid",
											"description": "Whether the setuid bit is set."
										},
										"setgid": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.setgid",
											"description": "Whether the setgid bit is set."
										},
										"sticky": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.sticky",
											"description": "Whether the sticky bit is set."
										},
										"user_read": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.user_read",
											"description": "Whether the file is readable by the owner."
										},
										"user_write": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.user_write",
											"description": "Whether the file is writable by the owner."
										},
										"user_exec": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.user_exec",
											"description": "Whether the file is executable by the owner."
										},
										"group_read": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.group_read",
											"description": "Whether the file is readable by the group."
										},
										"group_write": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.group_write",
											"description": "Whether the file is writable by the group."
										},
										"group_exec": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.group_exec",
											"description": "Whether the file is executable by the group."
										},
										"other_read": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.other_read",
											"description": "Whether the file is readable by others."
										},
										"other_write": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.other_write",
											"description": "Whether the file is writable by others."
										},
										"other_exec": {
											"type": [
												{
													"type": "boolean"
												}
											],
											"name": "perm.other_exec",
											"description": "Whether the file is executable by others."
										}
									}
								}
							],
							"name": "perm",
							"description": "The file permissions."
						},
						"inode": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "inode",
							"description": "The inode number."
						},
						"mode": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "mode",
							"description": "The file mode."
						},
						"nlink": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "nlink",
							"description": "The number of hard links."
						},
						"uid": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "uid",
							"description": "The user ID of the owner."
						},
						"gid": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "gid",
							"description": "The group ID of the owner."
						},
						"size": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "size",
							"description": "The file size in bytes."
						},
						"blksize": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "blksize",
							"description": "The block size for file system I/O."
						},
						"blocks": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "blocks",
							"description": "The number of 512-byte blocks allocated for the file."
						},
						"atime": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "atime",
							"description": "The timestamp when the file was last accessed."
						},
						"mtime": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "mtime",
							"description": "The timestamp when the file was last modified."
						},
						"ctime": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "ctime",
							"description": "The timestamp when the file status was last changed."
						},
						"type": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "type",
							"description": "The type of the file (\"directory\", \"file\", etc.)."
						}
					}
				}
			],
			"name": "module:fs.FileStatResult",
			"description": ""
		},
		"stat": {
			"kind": "function",
			"name": "module:fs#stat",
			"return": [
				{
					"type": "module:fs.FileStatResult",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				}
			},
			"subject": "Retrieves information about a file or directory.",
			"description": "Retrieves information about a file or directory.\n\nReturns an object containing information about the file or directory.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions."
		},
		"lstat": {
			"kind": "function",
			"name": "module:fs#lstat",
			"return": [
				{
					"type": "module:fs.FileStatResult",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				}
			},
			"subject": "Retrieves information about a file or directory, without following symbolic\nlinks.",
			"description": "Retrieves information about a file or directory, without following symbolic\nlinks.\n\nReturns an object containing information about the file or directory.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions."
		},
		"mkdir": {
			"kind": "function",
			"name": "module:fs#mkdir",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the new directory."
				}
			},
			"subject": "Creates a new directory.",
			"description": "Creates a new directory.\n\nReturns `true` if the directory was successfully created.\n\nReturns `null` if an error occurred, e.g. due to inexistent path."
		},
		"rmdir": {
			"kind": "function",
			"name": "module:fs#rmdir",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the directory to be removed."
				}
			},
			"subject": "Removes the specified directory.",
			"description": "Removes the specified directory.\n\nReturns `true` if the directory was successfully removed.\n\nReturns `null` if an error occurred, e.g. due to inexistent path."
		},
		"symlink": {
			"kind": "function",
			"name": "module:fs#symlink",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"target": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "target",
					"description": "The target of the symbolic link."
				},
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path of the symbolic link."
				}
			},
			"subject": "Creates a new symbolic link.",
			"description": "Creates a new symbolic link.\n\nReturns `true` if the symlink was successfully created.\n\nReturns `null` if an error occurred, e.g. due to inexistent path."
		},
		"unlink": {
			"kind": "function",
			"name": "module:fs#unlink",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or symbolic link."
				}
			},
			"subject": "Removes the specified file or symbolic link.",
			"description": "Removes the specified file or symbolic link.\n\nReturns `true` if the unlink operation was successful.\n\nReturns `null` if an error occurred, e.g. due to inexistent path."
		},
		"getcwd": {
			"kind": "function",
			"name": "module:fs#getcwd",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"subject": "Retrieves the current working directory.",
			"description": "Retrieves the current working directory.\n\nReturns a string containing the current working directory path.\n\nReturns `null` if an error occurred."
		},
		"chdir": {
			"kind": "function",
			"name": "module:fs#chdir",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the new working directory."
				}
			},
			"subject": "Changes the current working directory to the specified path.",
			"description": "Changes the current working directory to the specified path.\n\nReturns `true` if the permission change was successful.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions or\ninvalid arguments."
		},
		"chmod": {
			"kind": "function",
			"name": "module:fs#chmod",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				},
				"mode": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "mode",
					"description": "The new mode (permissions)."
				}
			},
			"subject": "Changes the permission mode bits of a file or directory.",
			"description": "Changes the permission mode bits of a file or directory.\n\nReturns `true` if the permission change was successful.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions or\ninvalid arguments."
		},
		"chown": {
			"kind": "function",
			"name": "module:fs#chown",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				},
				"uid": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "[uid=-1]",
					"description": "The new owner's user ID. When given as number, it is used as-is, when given\nas string, the user name is resolved to the corresponding uid first.",
					"default": "-1",
					"optional": true
				},
				"gid": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "[gid=-1]",
					"description": "The new group's ID. When given as number, it is used as-is, when given as\nstring, the group name is resolved to the corresponding gid first.",
					"default": "-1",
					"optional": true
				}
			},
			"subject": "Changes the owner and group of a file or directory.",
			"description": "Changes the owner and group of a file or directory.\n\nThe user and group may be specified either as uid or gid number respectively,\nor as a string containing the user or group name, in which case it is\nresolved to the proper uid/gid first.\n\nIf either the user or group parameter is omitted or given as `-1`,\nit is not changed.\n\nReturns `true` if the ownership change was successful.\n\nReturns `null` if an error occurred or if a user/group name cannot be\nresolved to a uid/gid value."
		},
		"rename": {
			"kind": "function",
			"name": "module:fs#rename",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"oldPath": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "oldPath",
					"description": "The current path of the file or directory."
				},
				"newPath": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "newPath",
					"description": "The new path of the file or directory."
				}
			},
			"subject": "Renames or moves a file or directory.",
			"description": "Renames or moves a file or directory.\n\nReturns `true` if the rename operation was successful.\n\nReturns `null` if an error occurred."
		},
		"dirname": {
			"kind": "function",
			"name": "module:fs#dirname",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to extract the directory name from."
				}
			},
			"subject": "Retrieves the directory name of a path.",
			"description": "Retrieves the directory name of a path.\n\nReturns the directory name component of the specified path.\n\nReturns `null` if the path argument is not a string."
		},
		"basename": {
			"kind": "function",
			"name": "module:fs#basename",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to extract the base name from."
				}
			},
			"subject": "Retrieves the base name of a path.",
			"description": "Retrieves the base name of a path.\n\nReturns the base name component of the specified path.\n\nReturns `null` if the path argument is not a string."
		},
		"lsdir": {
			"kind": "function",
			"name": "module:fs#lsdir",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "string"
						}
					],
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the directory."
				}
			},
			"subject": "Lists the content of a directory.",
			"description": "Lists the content of a directory.\n\nReturns a sorted array of the names of files and directories in the specified\ndirectory.\n\nReturns `null` if an error occurred, e.g. if the specified directory cannot\nbe opened."
		},
		"mkstemp": {
			"kind": "function",
			"name": "module:fs#mkstemp",
			"return": [
				{
					"type": "module:fs.file",
					"nullable": true
				}
			],
			"params": {
				"template": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[template=\"/tmp/XXXXXX\"]",
					"description": "The path template to use when forming the temporary file name.",
					"default": "\"/tmp/XXXXXX\"",
					"optional": true
				}
			},
			"subject": "Creates a unique, ephemeral temporary file.",
			"description": "Creates a unique, ephemeral temporary file.\n\nCreates a new temporary file, opens it in read and write mode, unlinks it and\nreturns a file handle object referring to the yet open but deleted file.\n\nUpon closing the handle, the associated file will automatically vanish from\nthe system.\n\nThe optional path template argument may be used to override the path and name\nchosen for the temporary file. If the path template contains no path element,\n`/tmp/` is prepended, if it does not end with `XXXXXX`, then  * `.XXXXXX` is\nappended to it. The `XXXXXX` sequence is replaced with a random value\nensuring uniqueness of the temporary file name.\n\nReturns a file handle object referring to the ephemeral file on success.\n\nReturns `null` if an error occurred, e.g. on insufficient permissions or\ninaccessible directory."
		},
		"access": {
			"kind": "function",
			"name": "module:fs#access",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				},
				"mode": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[mode=\"f\"]",
					"description": "Optional access mode.",
					"default": "\"f\"",
					"optional": true
				}
			},
			"subject": "Checks the accessibility of a file or directory.",
			"description": "Checks the accessibility of a file or directory.\n\nThe optional modes argument specifies the access modes which should be\nchecked. A file is only considered accessible if all access modes specified\nin the modes argument are possible.\n\nThe following modes are recognized:\n\n| Mode | Description                           |\n|------|---------------------------------------|\n| \"r\"  | Tests whether the file is readable.   |\n| \"w\"  | Tests whether the file is writable.   |\n| \"x\"  | Tests whether the file is executable. |\n| \"f\"  | Tests whether the file exists.        |\n\nReturns `true` if the given path is accessible or `false` when it is not.\n\nReturns `null` if an error occurred, e.g. due to inaccessible intermediate\npath components, invalid path arguments etc."
		},
		"readfile": {
			"kind": "function",
			"name": "module:fs#readfile",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file."
				},
				"limit": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[limit]",
					"description": "Number of bytes to limit the result to. When omitted, the entire content is\nreturned.",
					"optional": true
				}
			},
			"subject": "Reads the content of a file, optionally limited to the given amount of bytes.",
			"description": "Reads the content of a file, optionally limited to the given amount of bytes.\n\nReturns a string containing the file contents.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions."
		},
		"writefile": {
			"kind": "function",
			"name": "module:fs#writefile",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file."
				},
				"data": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "data",
					"description": "The data to be written."
				},
				"limit": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[limit]",
					"description": "Truncates the amount of data to be written to the specified amount of bytes.\nWhen omitted, the entire content is written.",
					"optional": true
				}
			},
			"subject": "Writes the given data to a file, optionally truncated to the given amount\nof bytes.",
			"description": "Writes the given data to a file, optionally truncated to the given amount\nof bytes.\n\nIn case the given data is not a string, it is converted to a string before\nbeing written into the file. String values are written as-is, integer and\ndouble values are written in decimal notation, boolean values are written as\n`true` or `false` while arrays and objects are converted to their JSON\nrepresentation before being written into the file. The `null` value is\nrepresented by an empty string so `writefile(…, null)` would write an empty\nfile. Resource values are written in the form `<type address>`, e.g.\n`<fs.file 0x7f60f0981760>`.\n\nIf resource, array or object values contain a `tostring()` function in their\nprototypes, then this function is invoked to obtain an alternative string\nrepresentation of the value.\n\nIf a file already exists at the given path, it is truncated. If no file\nexists, it is created with default permissions 0o666 masked by the currently\neffective umask.\n\nReturns the number of bytes written.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions."
		},
		"realpath": {
			"kind": "function",
			"name": "module:fs#realpath",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"path": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "path",
					"description": "The path to the file or directory."
				}
			},
			"subject": "Resolves the absolute path of a file or directory.",
			"description": "Resolves the absolute path of a file or directory.\n\nReturns a string containing the resolved path.\n\nReturns `null` if an error occurred, e.g. due to insufficient permissions."
		},
		"pipe": {
			"kind": "function",
			"name": "module:fs#pipe",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "module:fs.file"
						}
					],
					"nullable": true
				}
			],
			"subject": "Creates a pipe and returns file handle objects associated with the read- and\nwrite end of the pipe respectively.",
			"description": "Creates a pipe and returns file handle objects associated with the read- and\nwrite end of the pipe respectively.\n\nReturns a two element array containing both a file handle object open in read\nmode referring to the read end of the pipe and a file handle object open in\nwrite mode referring to the write end of the pipe.\n\nReturns `null` if an error occurred."
		}
	},
	"fs.proc": {
		"close": {
			"kind": "function",
			"name": "module:fs.proc#close",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"subject": "Closes the program handle and awaits program termination.",
			"description": "Closes the program handle and awaits program termination.\n\nUpon calling `close()` on the handle, the program's input or output stream\n(depending on the open mode) is closed. Afterwards, the function awaits the\ntermination of the underlying program and returns its exit code.\n\n- When the program was terminated by a signal, the return value will be the\nnegative signal number, e.g. `-9` for SIGKILL.\n\n- When the program terminated normally, the return value will be the positive\nexit code of the program.\n\nReturns a negative signal number if the program was terminated by a signal.\n\nReturns a positive exit code if the program terminated normally.\n\nReturns `null` if an error occurred."
		},
		"read": {
			"kind": "function",
			"name": "module:fs.proc#read",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"length": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "length",
					"description": "The length of data to read. Can be a number, the string \"line\", the string\n\"all\", or a single character string."
				}
			},
			"subject": "Reads a chunk of data from the program handle.",
			"description": "Reads a chunk of data from the program handle.\n\nThe length argument may be either a positive number of bytes to read, in\nwhich case the read call returns up to that many bytes, or a string to\nspecify a dynamic read size.\n\n- If length is a number, the method will read the specified number of bytes\nfrom the handle. Reading stops after the given amount of bytes or after\nencountering EOF, whatever comes first.\n\n- If length is the string \"line\", the method will read an entire line,\nterminated by \"\\n\" (a newline), from the handle. Reading stops at the next\nnewline or when encountering EOF. The returned data will contain the\nterminating newline character if one was read.\n\n- If length is the string \"all\", the method will read from the handle until\nencountering EOF and return the complete contents.\n\n- If length is a single character string, the method will read from the\nhandle until encountering the specified character or upon encountering\nEOF. The returned data will contain the terminating character if one was\nread.\n\nReturns a string containing the read data.\n\nReturns an empty string on EOF.\n\nReturns `null` if a read error occurred."
		},
		"write": {
			"kind": "function",
			"name": "module:fs.proc#write",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"data": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "data",
					"description": "The data to be written."
				}
			},
			"subject": "Writes a chunk of data to the program handle.",
			"description": "Writes a chunk of data to the program handle.\n\nIn case the given data is not a string, it is converted to a string before\nbeing written to the program's stdin. String values are written as-is,\ninteger and double values are written in decimal notation, boolean values are\nwritten as `true` or `false` while arrays and objects are converted to their\nJSON representation before being written. The `null` value is represented by\nan empty string so `proc.write(null)` would be a no-op. Resource values are\nwritten in the form `<type address>`, e.g. `<fs.file 0x7f60f0981760>`.\n\nIf resource, array or object values contain a `tostring()` function in their\nprototypes, then this function is invoked to obtain an alternative string\nrepresentation of the value.\n\nReturns the number of bytes written.\n\nReturns `null` if a write error occurred."
		},
		"flush": {
			"kind": "function",
			"name": "module:fs.proc#flush",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Forces a write of all buffered data to the underlying handle.",
			"description": "Forces a write of all buffered data to the underlying handle.\n\nReturns `true` if the data was successfully flushed.\n\nReturns `null` on error."
		},
		"fileno": {
			"kind": "function",
			"name": "module:fs.proc#fileno",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"subject": "Obtains the number of the handle's underlying file descriptor.",
			"description": "Obtains the number of the handle's underlying file descriptor.\n\nReturns the descriptor number.\n\nReturns `null` on error."
		}
	},
	"fs.file": {
		"close": {
			"kind": "function",
			"name": "module:fs.file#close",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Closes the file handle.",
			"description": "Closes the file handle.\n\nUpon calling `close()` on the handle, buffered data is flushed and the\nunderlying file descriptor is closed.\n\nReturns `true` if the handle was properly closed.\n\nReturns `null` if an error occurred."
		},
		"read": {
			"kind": "function",
			"name": "module:fs.file#read",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"length": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "length",
					"description": "The length of data to read. Can be a number, the string \"line\", the string\n\"all\", or a single character string."
				}
			},
			"subject": "Reads a chunk of data from the file handle.",
			"description": "Reads a chunk of data from the file handle.\n\nThe length argument may be either a positive number of bytes to read, in\nwhich case the read call returns up to that many bytes, or a string to\nspecify a dynamic read size.\n\n- If length is a number, the method will read the specified number of bytes\nfrom the handle. Reading stops after the given amount of bytes or after\nencountering EOF, whatever comes first.\n\n- If length is the string \"line\", the method will read an entire line,\nterminated by \"\\n\" (a newline), from the handle. Reading stops at the next\nnewline or when encountering EOF. The returned data will contain the\nterminating newline character if one was read.\n\n- If length is the string \"all\", the method will read from the handle until\nencountering EOF and return the complete contents.\n\n- If length is a single character string, the method will read from the\nhandle until encountering the specified character or upon encountering\nEOF. The returned data will contain the terminating character if one was\nread.\n\nReturns a string containing the read data.\n\nReturns an empty string on EOF.\n\nReturns `null` if a read error occurred."
		},
		"write": {
			"kind": "function",
			"name": "module:fs.file#write",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"data": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "data",
					"description": "The data to be written."
				}
			},
			"subject": "Writes a chunk of data to the file handle.",
			"description": "Writes a chunk of data to the file handle.\n\nIn case the given data is not a string, it is converted to a string before\nbeing written into the file. String values are written as-is, integer and\ndouble values are written in decimal notation, boolean values are written as\n`true` or `false` while arrays and objects are converted to their JSON\nrepresentation before being written. The `null` value is represented by an\nempty string so `file.write(null)` would be a no-op. Resource values are\nwritten in the form `<type address>`, e.g. `<fs.file 0x7f60f0981760>`.\n\nIf resource, array or object values contain a `tostring()` function in their\nprototypes, then this function is invoked to obtain an alternative string\nrepresentation of the value.\n\nReturns the number of bytes written.\n\nReturns `null` if a write error occurred."
		},
		"seek": {
			"kind": "function",
			"name": "module:fs.file#seek",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[offset=0]",
					"description": "The offset in bytes.",
					"default": "0",
					"optional": true
				},
				"position": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[position=0]",
					"description": "The position of the offset.\n\n| Position | Description                                                                                  |\n|----------|----------------------------------------------------------------------------------------------|\n| `0`      | The given offset is relative to the start of the file. This is the default value if omitted. |\n| `1`      | The given offset is relative to the current read position.                                   |\n| `2`      | The given offset is relative to the end of the file.                                         |",
					"default": "0",
					"optional": true
				}
			},
			"subject": "Set file read position.",
			"description": "Set file read position.\n\nSet the read position of the open file handle to the given offset and\nposition.\n\nReturns `true` if the read position was set.\n\nReturns `null` if an error occurred."
		},
		"truncate": {
			"kind": "function",
			"name": "module:fs.file#truncate",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[offset=0]",
					"description": "The offset in bytes.",
					"default": "0",
					"optional": true
				}
			},
			"subject": "Truncate file to a given size",
			"description": "Truncate file to a given size\n\nReturns `true` if the file was successfully truncated.\n\nReturns `null` if an error occurred."
		},
		"lock": {
			"kind": "function",
			"name": "module:fs.file#lock",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"op": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[op]",
					"description": "The lock operation flags",
					"optional": true
				}
			},
			"subject": "Locks or unlocks a file.",
			"description": "Locks or unlocks a file.\n\nThe mode argument specifies lock/unlock operation flags.\n\n| Flag    | Description                  |\n|---------|------------------------------|\n| \"s\"     | shared lock                  |\n| \"x\"     | exclusive lock               |\n| \"n\"     | don't block when locking     |\n| \"u\"     | unlock                       |\n\nReturns `true` if the file was successfully locked/unlocked.\n\nReturns `null` if an error occurred."
		},
		"tell": {
			"kind": "function",
			"name": "module:fs.file#tell",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"subject": "Obtain current read position.",
			"description": "Obtain current read position.\n\nObtains the current, absolute read position of the open file.\n\nReturns an integer containing the current read offset in bytes.\n\nReturns `null` if an error occurred."
		},
		"isatty": {
			"kind": "function",
			"name": "module:fs.file#isatty",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Check for TTY.",
			"description": "Check for TTY.\n\nChecks whether the open file handle refers to a TTY (terminal) device.\n\nReturns `true` if the handle refers to a terminal.\n\nReturns `false` if the handle refers to another kind of file.\n\nReturns `null` on error."
		},
		"flush": {
			"kind": "function",
			"name": "module:fs.file#flush",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Forces a write of all buffered data to the underlying handle.",
			"description": "Forces a write of all buffered data to the underlying handle.\n\nReturns `true` if the data was successfully flushed.\n\nReturns `null` on error."
		},
		"fileno": {
			"kind": "function",
			"name": "module:fs.file#fileno",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"subject": "Obtains the number of the handle's underlying file descriptor.",
			"description": "Obtains the number of the handle's underlying file descriptor.\n\nReturns the descriptor number.\n\nReturns `null` on error."
		}
	},
	"fs.dir": {
		"read": {
			"kind": "function",
			"name": "module:fs.dir#read",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"subject": "Read the next entry from the open directory.",
			"description": "Read the next entry from the open directory.\n\nReturns a string containing the entry name.\n\nReturns `null` if there are no more entries to read.\n\nReturns `null` if an error occurred."
		},
		"tell": {
			"kind": "function",
			"name": "module:fs.dir#tell",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"subject": "Obtain current read position.",
			"description": "Obtain current read position.\n\nReturns the current read position in the open directory handle which can be\npassed back to the `seek()` function to return to this position. This is\nmainly useful to read an open directory handle (or specific items) multiple\ntimes.\n\nReturns an integer referring to the current position.\n\nReturns `null` if an error occurred."
		},
		"seek": {
			"kind": "function",
			"name": "module:fs.dir#seek",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "offset",
					"description": "Position value obtained by `tell()`."
				}
			},
			"subject": "Set read position.",
			"description": "Set read position.\n\nSets the read position within the open directory handle to the given offset\nvalue. The offset value should be obtained by a previous call to `tell()` as\nthe specific integer values are implementation defined.\n\nReturns `true` if the read position was set.\n\nReturns `null` if an error occurred."
		},
		"close": {
			"kind": "function",
			"name": "module:fs.dir#close",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Closes the directory handle.",
			"description": "Closes the directory handle.\n\nCloses the underlying file descriptor referring to the opened directory.\n\nReturns `true` if the handle was properly closed.\n\nReturns `null` if an error occurred."
		}
	},
	"log": {
		"LogOption": {
			"kind": "typedef",
			"type": [
				{
					"type": "module:log.LogOption"
				}
			],
			"name": "module:log.LogOption",
			"subject": "The following log option strings are recognized:",
			"description": "The following log option strings are recognized:\n\n| Log Option | Description                                                |\n|------------|------------------------------------------------------------|\n| `\"pid\"`    | Include PID with each message.                             |\n| `\"cons\"`   | Log to console if an error occurs while sending to syslog. |\n| `\"ndelay\"` | Open the connection to the logger immediately.             |\n| `\"odelay\"` | Delay open until the first message is logged.              |\n| `\"nowait\"` | Do not wait for child processes created during logging.    |"
		},
		"LogFacility": {
			"kind": "typedef",
			"type": [
				{
					"type": "module:log.LogFacility"
				}
			],
			"name": "module:log.LogFacility",
			"subject": "The following log facility strings are recognized:",
			"description": "The following log facility strings are recognized:\n\n| Facility     | Description                                      |\n|--------------|--------------------------------------------------|\n| `\"auth\"`     | Authentication/authorization messages.           |\n| `\"authpriv\"` | Private authentication messages.                 |\n| `\"cron\"`     | Clock daemon (cron and at commands).             |\n| `\"daemon\"`   | System daemons without separate facility values. |\n| `\"ftp\"`      | FTP server daemon.                               |\n| `\"kern\"`     | Kernel messages.                                 |\n| `\"lpr\"`      | Line printer subsystem.                          |\n| `\"mail\"`     | Mail system.                                     |\n| `\"news\"`     | Network news subsystem.                          |\n| `\"syslog\"`   | Messages generated internally by syslogd.        |\n| `\"user\"`     | Generic user-level messages.                     |\n| `\"uucp\"`     | UUCP subsystem.                                  |\n| `\"local0\"`   | Local use 0 (custom facility).                   |\n| `\"local1\"`   | Local use 1 (custom facility).                   |\n| `\"local2\"`   | Local use 2 (custom facility).                   |\n| `\"local3\"`   | Local use 3 (custom facility).                   |\n| `\"local4\"`   | Local use 4 (custom facility).                   |\n| `\"local5\"`   | Local use 5 (custom facility).                   |\n| `\"local6\"`   | Local use 6 (custom facility).                   |\n| `\"local7\"`   | Local use 7 (custom facility).                   |"
		},
		"LogPriority": {
			"kind": "typedef",
			"type": [
				{
					"type": "module:log.LogPriority"
				}
			],
			"name": "module:log.LogPriority",
			"subject": "The following log priority strings are recognized:",
			"description": "The following log priority strings are recognized:\n\n| Priority    | Description                         |\n|-------------|-------------------------------------|\n| `\"emerg\"`   | System is unusable.                 |\n| `\"alert\"`   | Action must be taken immediately.   |\n| `\"crit\"`    | Critical conditions.                |\n| `\"err\"`     | Error conditions.                   |\n| `\"warning\"` | Warning conditions.                 |\n| `\"notice\"`  | Normal, but significant, condition. |\n| `\"info\"`    | Informational message.              |\n| `\"debug\"`   | Debug-level message.                |"
		},
		"openlog": {
			"kind": "function",
			"name": "module:log#openlog",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"ident": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[ident]",
					"description": "A string identifying the program name. If omitted, the name of the calling\nprocess is used by default.",
					"optional": true
				},
				"options": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogOption"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "module:log.LogOption"
								}
							]
						}
					],
					"name": "[options]",
					"description": "Logging options to use.\n\nSee {@link module:log.LogOption|LogOption} for recognized option names.",
					"optional": true
				},
				"facility": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogFacility"
						}
					],
					"name": "[facility=\"user\"]",
					"description": "The facility to use for log messages generated by subsequent syslog calls.\n\nSee {@link module:log.LogFacility|LogFacility} for recognized facility names.",
					"default": "\"user\"",
					"optional": true
				}
			},
			"subject": "Open connection to system logger.",
			"description": "Open connection to system logger.\n\nThe `openlog()` function instructs the program to establish a connection to\nthe system log service and configures the default facility and identification\nfor use in subsequent log operations. It may be omitted, in which case the\nfirst call to `syslog()` will implicitly call `openlog()` with a default\nident value representing the program name and a default `LOG_USER` facility.\n\nThe log option argument may be either a single string value containing an\noption name, an array of option name strings or a numeric value representing\na bitmask of `LOG_*` option constants.\n\nThe facility argument may be either a single string value containing a\nfacility name or one of the numeric `LOG_*` facility constants in the module\nnamespace.\n\nReturns `true` if the system `openlog()` function was invoked.\n\nReturns `false` if an invalid argument, such as an unrecognized option or\nfacility name, was provided."
		},
		"syslog": {
			"kind": "function",
			"name": "module:log#syslog",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"priority": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogPriority"
						}
					],
					"name": "priority",
					"description": "Log message priority. May be either a number value (potentially bitwise OR-ed\nwith a log facility constant) which is passed as-is to the system `syslog()`\nfunction or a priority name string.\n\nSee {@link module:log.LogPriority|LogPriority} for recognized priority names."
				},
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Log a message to the system logger.",
			"description": "Log a message to the system logger.\n\nThis function logs a message to the system logger. The function behaves in a\nsprintf-like manner, allowing the use of format strings and associated\narguments to construct log messages.\n\nIf the `openlog` function has not been called explicitly before, `syslog()`\nimplicitly calls `openlog()`, using a default ident and `LOG_USER` facility\nvalue before logging the message.\n\nIf the `format` argument is not a string and not `null`, it will be\nimplicitly converted to a string and logged as-is, without further format\nstring processing.\n\nReturns `true` if a message was passed to the system `syslog()` function.\n\nReturns `false` if an invalid priority value or an empty message was given."
		},
		"closelog": {
			"kind": "function",
			"name": "module:log#closelog",
			"subject": "Close connection to system logger.",
			"description": "Close connection to system logger.\n\nThe usage of this function is optional, and usually an explicit log\nconnection tear down is not required."
		},
		"UlogChannel": {
			"kind": "typedef",
			"type": [
				{
					"type": "module:log.UlogChannel"
				}
			],
			"name": "module:log.UlogChannel",
			"subject": "The following ulog channel strings are recognized:",
			"description": "The following ulog channel strings are recognized:\n\n| Channel    | Description                                       |\n|------------|---------------------------------------------------|\n| `\"kmsg\"`   | Log to `/dev/kmsg`, log messages appear in dmesg. |\n| `\"syslog\"` | Use standard `syslog()` mechanism.                |\n| `\"stdio\"`  | Use stderr for log output.                        |"
		},
		"ulog_open": {
			"kind": "function",
			"name": "module:log#ulog_open",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"channel": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.UlogChannel"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "module:log.UlogChannel"
								}
							]
						}
					],
					"name": "[channel]",
					"description": "Specifies the log channels to use.\n\nSee {@link module:log.UlogChannel|UlogChannel} for recognized channel names.",
					"optional": true
				},
				"facility": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogFacility"
						}
					],
					"name": "[facility]",
					"description": "The facility to use for log messages generated by subsequent `ulog()` calls.\n\nSee {@link module:log.LogFacility|LogFacility} for recognized facility names.",
					"optional": true
				},
				"ident": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[ident]",
					"description": "A string identifying the program name. If omitted, the name of the calling\nprocess is used by default.",
					"optional": true
				}
			},
			"subject": "Configure ulog logger.",
			"description": "Configure ulog logger.\n\nThis functions configures the ulog mechanism and is analogeous to using the\n`openlog()` function in conjuncton with `syslog()`.\n\nThe `ulog_open()` function is OpenWrt specific and may not be present on\nother systems. Use `openlog()` and `syslog()` instead for portability to\nnon-OpenWrt environments.\n\nA program may use multiple channels to simultaneously output messages using\ndifferent means. The channel argument may either be a single string value\ncontaining a channel name, an array of channel names or a numeric value\nrepresenting a bitmask of `ULOG_*` channel constants.\n\nThe facility argument may be either a single string value containing a\nfacility name or one of the numeric `LOG_*` facility constants in the module\nnamespace.\n\nThe default facility value varies, depending on the execution context of the\nprogram. In OpenWrt's preinit boot phase, or when stdout is not connected to\nan interactive terminal, the facility defaults to `\"daemon\"` (`LOG_DAEMON`),\notherwise to `\"user\"` (`LOG_USER`).\n\nLikewise, the default channel is selected depending on the context. During\nOpenWrt's preinit boot phase, the `\"kmsg\"` channel is used, for interactive\nterminals the `\"stdio\"` one and for all other cases the `\"syslog\"` channel\nis selected.\n\nReturns `true` if ulog was configured.\n\nReturns `false` if an invalid argument, such as an unrecognized channel or\nfacility name, was provided."
		},
		"ulog": {
			"kind": "function",
			"name": "module:log#ulog",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"priority": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogPriority"
						}
					],
					"name": "priority",
					"description": "Log message priority. May be either a number value or a priority name string.\n\nSee {@link module:log.LogPriority|LogPriority} for recognized priority names."
				},
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Log a message via the ulog mechanism.",
			"description": "Log a message via the ulog mechanism.\n\nThe `ulog()` function outputs the given log message to all configured ulog\nchannels unless the given priority level exceeds the globally configured ulog\npriority threshold. See {@link module:log#ulog_threshold|ulog_threshold()}\nfor details.\n\nThe `ulog()` function is OpenWrt specific and may not be present on other\nsystems. Use `syslog()` instead for portability to non-OpenWrt environments.\n\nLike `syslog()`, the function behaves in a sprintf-like manner, allowing the\nuse of format strings and associated arguments to construct log messages.\n\nIf the `ulog_open()` function has not been called explicitly before, `ulog()`\nimplicitly configures certain defaults, see\n{@link module:log#ulog_open|ulog_open()} for a detailled description.\n\nIf the `format` argument is not a string and not `null`, it will be\nimplicitly converted to a string and logged as-is, without further format\nstring processing.\n\nReturns `true` if a message was passed to the underlying `ulog()` function.\n\nReturns `false` if an invalid priority value or an empty message was given."
		},
		"ulog_close": {
			"kind": "function",
			"name": "module:log#ulog_close",
			"subject": "Close ulog logger.",
			"description": "Close ulog logger.\n\nResets the ulog channels, the default facility and the log ident value to\ndefaults.\n\nIn case the `\"syslog\"` channel has been configured, the underlying\n`closelog()` function will be invoked.\n\nThe usage of this function is optional, and usually an explicit ulog teardown\nis not required.\n\nThe `ulog_close()` function is OpenWrt specific and may not be present on\nother systems. Use `closelog()` in conjunction with `syslog()` instead for\nportability to non-OpenWrt environments."
		},
		"ulog_threshold": {
			"kind": "function",
			"name": "module:log#ulog_threshold",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"priority": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:log.LogPriority"
						}
					],
					"name": "[priority]",
					"description": "The priority threshold to configure.\n\nSee {@link module:log.LogPriority|LogPriority} for recognized priority names.",
					"optional": true
				}
			},
			"subject": "Set ulog priority threshold.",
			"description": "Set ulog priority threshold.\n\nThis function configures the application wide log message threshold for log\nmessages emitted with `ulog()`. Any message with a priority higher (= less\nsevere) than the threshold priority will be discarded. This is useful to\nimplement application wide verbosity settings without having to wrap `ulog()`\ninvocations into a helper function or guarding code.\n\nWhen no explicit threshold has been set, `LOG_DEBUG` is used by default,\nallowing log messages with all known priorities.\n\nThe `ulog_threshold()` function is OpenWrt specific and may not be present on\nother systems. There is no syslog equivalent to this ulog specific threshold\nmechanism.\n\nThe priority argument may be either a string value containing a priority name\nor one of the numeric `LOG_*` priority constants in the module namespace.\n\nReturns `true` if a threshold was set.\n\nReturns `false` if an invalid priority value was given."
		},
		"INFO": {
			"kind": "function",
			"name": "module:log#INFO",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Invoke ulog with LOG_INFO.",
			"description": "Invoke ulog with LOG_INFO.\n\nThis function is convenience wrapper for `ulog(LOG_INFO, ...)`.\n\nSee {@link module:log#ulog|ulog()} for details."
		},
		"NOTE": {
			"kind": "function",
			"name": "module:log#NOTE",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Invoke ulog with LOG_NOTICE.",
			"description": "Invoke ulog with LOG_NOTICE.\n\nThis function is convenience wrapper for `ulog(LOG_NOTICE, ...)`.\n\nSee {@link module:log#ulog|ulog()} for details."
		},
		"WARN": {
			"kind": "function",
			"name": "module:log#WARN",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Invoke ulog with LOG_WARNING.",
			"description": "Invoke ulog with LOG_WARNING.\n\nThis function is convenience wrapper for `ulog(LOG_WARNING, ...)`.\n\nSee {@link module:log#ulog|ulog()} for details."
		},
		"ERR": {
			"kind": "function",
			"name": "module:log#ERR",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "format",
					"description": "The sprintf-like format string for the log message, or any other, non-null,\nnon-string value type which will be implicitly stringified and logged as-is."
				},
				"args": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "[args]",
					"description": "In case a format string value was provided in the previous argument, then\nall subsequent arguments are used to replace the placeholders in the format\nstring.",
					"optional": true
				}
			},
			"subject": "Invoke ulog with LOG_ERR.",
			"description": "Invoke ulog with LOG_ERR.\n\nThis function is convenience wrapper for `ulog(LOG_ERR, ...)`.\n\nSee {@link module:log#ulog|ulog()} for details."
		}
	},
	"math": {
		"abs": {
			"kind": "function",
			"name": "module:math#abs",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the absolute value of the given numeric value.",
			"params": {
				"number": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "number",
					"description": "The number to return the absolute value for."
				}
			},
			"subject": "Returns the absolute value of the given numeric value."
		},
		"atan2": {
			"kind": "function",
			"name": "module:math#atan2",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"y": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "y",
					"description": "The `y` value."
				},
				"x": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "x",
					"description": "The `x` value."
				}
			},
			"subject": "Calculates the principal value of the arc tangent of `y`/`x`,\nusing the signs of the two arguments to determine the quadrant\nof the result.",
			"description": "Calculates the principal value of the arc tangent of `y`/`x`,\nusing the signs of the two arguments to determine the quadrant\nof the result.\n\nOn success, this function returns the principal value of the arc\ntangent of `y`/`x` in radians; the return value is in the range [-pi, pi].\n\n- If `y` is +0 (-0) and `x` is less than 0, +pi (-pi) is returned.\n- If `y` is +0 (-0) and `x` is greater than 0, +0 (-0) is returned.\n- If `y` is less than 0 and `x` is +0 or -0, -pi/2 is returned.\n- If `y` is greater than 0 and `x` is +0 or -0, pi/2 is returned.\n- If either `x` or `y` is NaN, a NaN is returned.\n- If `y` is +0 (-0) and `x` is -0, +pi (-pi) is returned.\n- If `y` is +0 (-0) and `x` is +0, +0 (-0) is returned.\n- If `y` is a finite value greater (less) than 0, and `x` is negative\ninfinity, +pi (-pi) is returned.\n- If `y` is a finite value greater (less) than 0, and `x` is positive\ninfinity, +0 (-0) is returned.\n- If `y` is positive infinity (negative infinity), and `x` is finite,\npi/2 (-pi/2) is returned.\n- If `y` is positive infinity (negative infinity) and `x` is negative\ninfinity, +3*pi/4 (-3*pi/4) is returned.\n- If `y` is positive infinity (negative infinity) and `x` is positive\ninfinity, +pi/4 (-pi/4) is returned.\n\nWhen either `x` or `y` can't be converted to a numeric value, `NaN` is\nreturned."
		},
		"cos": {
			"kind": "function",
			"name": "module:math#cos",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "Radians value to calculate cosine for."
				}
			},
			"subject": "Calculates the cosine of `x`, where `x` is given in radians.",
			"description": "Calculates the cosine of `x`, where `x` is given in radians.\n\nReturns the resulting consine value.\n\nReturns `NaN` if the `x` value can't be converted to a number."
		},
		"exp": {
			"kind": "function",
			"name": "module:math#exp",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "Power to raise `e` to."
				}
			},
			"subject": "Calculates the value of `e` (the base of natural logarithms)\nraised to the power of `x`.",
			"description": "Calculates the value of `e` (the base of natural logarithms)\nraised to the power of `x`.\n\nOn success, returns the exponential value of `x`.\n\n- If `x` is positive infinity, positive infinity is returned.\n- If `x` is negative infinity, `+0` is returned.\n- If the result underflows, a range error occurs, and zero is returned.\n- If the result overflows, a range error occurs, and `Infinity` is returned.\n\nReturns `NaN` if the `x` value can't be converted to a number."
		},
		"log": {
			"kind": "function",
			"name": "module:math#log",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "Value to calulate natural logarithm of."
				}
			},
			"subject": "Calculates the natural logarithm of `x`.",
			"description": "Calculates the natural logarithm of `x`.\n\nOn success, returns the natural logarithm of `x`.\n\n- If `x` is `1`, the result is `+0`.\n- If `x` is positive nfinity, positive infinity is returned.\n- If `x` is zero, then a pole error occurs, and the function\nreturns negative infinity.\n- If `x` is negative (including negative infinity), then a domain\nerror occurs, and `NaN` is returned.\n\nReturns `NaN` if the `x` value can't be converted to a number."
		},
		"sin": {
			"kind": "function",
			"name": "module:math#sin",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "Radians value to calculate sine for."
				}
			},
			"subject": "Calculates the sine of `x`, where `x` is given in radians.",
			"description": "Calculates the sine of `x`, where `x` is given in radians.\n\nReturns the resulting sine value.\n\n- When `x` is positive or negative infinity, a domain error occurs\nand `NaN` is returned.\n\nReturns `NaN` if the `x` value can't be converted to a number."
		},
		"sqrt": {
			"kind": "function",
			"name": "module:math#sqrt",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "Value to calculate square root for."
				}
			},
			"subject": "Calculates the nonnegative square root of `x`.",
			"description": "Calculates the nonnegative square root of `x`.\n\nReturns the resulting square root value.\n\n- If `x` is `+0` (`-0`) then `+0` (`-0`) is returned.\n- If `x` is positive infinity, positive infinity is returned.\n- If `x` is less than `-0`, a domain error occurs, and `NaN` is returned.\n\nReturns `NaN` if the `x` value can't be converted to a number."
		},
		"pow": {
			"kind": "function",
			"name": "module:math#pow",
			"return": [
				{
					"type": "number"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "The base value."
				},
				"y": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "y",
					"description": "The power value."
				}
			},
			"subject": "Calculates the value of `x` raised to the power of `y`.",
			"description": "Calculates the value of `x` raised to the power of `y`.\n\nOn success, returns the value of `x` raised to the power of `y`.\n\n- If the result overflows, a range error occurs, and the function\nreturns `Infinity`.\n- If result underflows, and is not representable, a range error\noccurs, and `0.0` with the appropriate sign is returned.\n- If `x` is `+0` or `-0`, and `y` is an odd integer less than `0`,\na pole error occurs `Infinity` is returned, with the same sign\nas `x`.\n- If `x` is `+0` or `-0`, and `y` is less than `0` and not an odd\ninteger, a pole error occurs and `Infinity` is returned.\n- If `x` is `+0` (`-0`), and `y` is an odd integer greater than `0`,\nthe result is `+0` (`-0`).\n- If `x` is `0`, and `y` greater than `0` and not an odd integer,\nthe result is `+0`.\n- If `x` is `-1`, and `y` is positive infinity or negative infinity,\nthe result is `1.0`.\n- If `x` is `+1`, the result is `1.0` (even if `y` is `NaN`).\n- If `y` is `0`, the result is `1.0` (even if `x` is `NaN`).\n- If `x` is a finite value less than `0`, and `y` is a finite\nnoninteger, a domain error occurs, and `NaN` is returned.\n- If the absolute value of `x` is less than `1`, and `y` is negative\ninfinity, the result is positive infinity.\n- If the absolute value of `x` is greater than `1`, and `y` is\nnegative infinity, the result is `+0`.\n- If the absolute value of `x` is less than `1`, and `y` is positive\ninfinity, the result is `+0`.\n- If the absolute value of `x` is greater than `1`, and `y` is positive\ninfinity, the result is positive infinity.\n- If `x` is negative infinity, and `y` is an odd integer less than `0`,\nthe result is `-0`.\n- If `x` is negative infinity, and `y` less than `0` and not an odd\ninteger, the result is `+0`.\n- If `x` is negative infinity, and `y` is an odd integer greater than\n`0`, the result is negative infinity.\n- If `x` is negative infinity, and `y` greater than `0` and not an odd\ninteger, the result is positive infinity.\n- If `x` is positive infinity, and `y` less than `0`, the result is `+0`.\n- If `x` is positive infinity, and `y` greater than `0`, the result is\npositive infinity.\n\nReturns `NaN` if either the `x` or `y` value can't be converted to a number."
		},
		"rand": {
			"kind": "function",
			"name": "module:math#rand",
			"return": [
				{
					"type": "number"
				}
			],
			"subject": "Produces a pseudo-random positive integer.",
			"description": "Produces a pseudo-random positive integer.\n\nReturns the calculated pseuo-random value. The value is within the range\n`0` to `RAND_MAX` inclusive where `RAND_MAX` is a platform specific value\nguaranteed to be at least `32767`.\n\nThe {@link module:math~srand `srand()`} function sets its argument as the\nseed for a new sequence of pseudo-random integers to be returned by `rand()`. These sequences are\nrepeatable by calling {@link module:math~srand `srand()`} with the same\nseed value.\n\nIf no seed value is explicitly set by calling\n{@link module:math~srand `srand()`} prior to the first call to `rand()`,\nthe math module will automatically seed the PRNG once, using the current\ntime of day in milliseconds as seed value."
		},
		"srand": {
			"kind": "function",
			"name": "module:math#srand",
			"params": {
				"seed": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "seed",
					"description": "The seed value."
				}
			},
			"subject": "Seeds the pseudo-random number generator.",
			"description": "Seeds the pseudo-random number generator.\n\nThis functions seeds the PRNG with the given value and thus affects the\npseudo-random integer sequence produced by subsequent calls to\n{@link module:math~rand `rand()`}.\n\nSetting the same seed value will result in the same pseudo-random numbers\nproduced by {@link module:math~rand `rand()`}."
		},
		"isnan": {
			"kind": "function",
			"name": "module:math#isnan",
			"return": [
				{
					"type": "boolean"
				}
			],
			"params": {
				"x": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "x",
					"description": "The value to test."
				}
			},
			"subject": "Tests whether `x` is a `NaN` double.",
			"description": "Tests whether `x` is a `NaN` double.\n\nThis functions checks whether the given argument is of type `double` with\na `NaN` (not a number) value.\n\nReturns `true` if the value is `NaN`, otherwise false.\n\nNote that a value can also be checked for `NaN` with the expression\n`x !== x` which only evaluates to `true` if `x` is `NaN`."
		}
	},
	"socket": {
		"AddressInfo": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"addr": {
							"type": [
								{
									"type": "module:socket.socket.SocketAddress"
								}
							],
							"name": "addr",
							"description": "A socket address structure."
						},
						"canonname": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "[canonname=null]",
							"description": "The canonical hostname associated with the address."
						},
						"family": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "family",
							"description": "The address family (e.g., `2` for `AF_INET`, `10` for `AF_INET6`)."
						},
						"flags": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "flags",
							"description": "Additional flags indicating properties of the address."
						},
						"protocol": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "protocol",
							"description": "The protocol number."
						},
						"socktype": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "socktype",
							"description": "The socket type (e.g., `1` for `SOCK_STREAM`, `2` for `SOCK_DGRAM`)."
						}
					}
				}
			],
			"name": "module:socket.AddressInfo",
			"default": "null",
			"optional": true,
			"subject": "Represents a network address information object returned by\n{@link module:socket#addrinfo|`addrinfo()`}.",
			"description": "Represents a network address information object returned by\n{@link module:socket#addrinfo|`addrinfo()`}."
		},
		"error": {
			"kind": "function",
			"name": "module:socket#error",
			"return": [
				{
					"type": "string",
					"nullable": true
				},
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"numeric": {
					"type": [
						{
							"type": "boolean"
						}
					],
					"name": "[numeric]",
					"description": "Whether to return a numeric error code (`true`) or a human readable error\nmessage (false).",
					"optional": true
				}
			},
			"subject": "Query error information.",
			"description": "Query error information.\n\nReturns a string containing a description of the last occurred error when\nthe *numeric* argument is absent or false.\n\nReturns a positive (`errno`) or negative (`EAI_*` constant) error code number\nwhen the *numeric* argument is `true`.\n\nReturns `null` if there is no error information."
		},
		"sockaddr": {
			"kind": "function",
			"name": "module:socket#sockaddr",
			"return": [
				{
					"type": "module:socket.socket.SocketAddress",
					"nullable": true
				}
			],
			"description": "Parses the provided address value into a socket address representation.\n\nThis function parses the given address value into a socket address\nrepresentation required for a number of socket operations. The address value\ncan be provided in various formats:\n- For IPv4 addresses, it can be a string representing the IP address,\noptionally followed by a port number separated by colon, e.g.\n`192.168.0.1:8080`.\n- For IPv6 addresses, it must be an address string enclosed in square\nbrackets if a port number is specified, otherwise the brackets are\noptional. The address string may also include a scope ID in the form\n`%ifname` or `%number`, e.g. `[fe80::1%eth0]:8080` or `fe80::1%15`.\n- Any string value containing a slash is treated as UNIX domain socket path.\n- Alternatively, it can be provided as an array returned by\n{@link module:core#iptoarr|iptoarr()}, representing the address octets.\n- It can also be an object representing a network address, with properties\nfor `address` (the IP address) and `port` or a single property `path` to\ndenote a UNIX domain socket address.",
			"params": {
				"address": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "address",
					"description": "The address value to parse."
				}
			},
			"subject": "Parses the provided address value into a socket address representation."
		},
		"nameinfo": {
			"kind": "function",
			"name": "module:socket#nameinfo",
			"return": [
				{
					"type": "object",
					"nullable": true,
					"properties": {
						"hostname": {
							"name": "hostname",
							"type": [
								{
									"type": "string"
								}
							]
						},
						"service": {
							"name": "service",
							"type": [
								{
									"type": "string"
								}
							]
						}
					}
				}
			],
			"params": {
				"address": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "address",
					"description": "The network address to resolve. It can be specified as:\n- A string representing the IP address.\n- An object representing the address with properties `address` and `port`."
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags that provide additional control over the resolution process,\nspecified as bitwise OR-ed number of `NI_*` constants.",
					"optional": true
				}
			},
			"subject": "Resolves the given network address into hostname and service name.",
			"description": "Resolves the given network address into hostname and service name.\n\nThe `nameinfo()` function provides an API for reverse DNS lookup and service\nname resolution. It returns an object containing the following properties:\n- `hostname`: The resolved hostname.\n- `service`: The resolved service name.\n\nReturns an object representing the resolved hostname and service name.\nReturn `null` if an error occurred during resolution."
		},
		"addrinfo": {
			"kind": "function",
			"name": "module:socket#addrinfo",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "module:socket.AddressInfo"
						}
					],
					"nullable": true
				}
			],
			"params": {
				"hostname": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "hostname",
					"description": "The hostname to resolve."
				},
				"service": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[service]",
					"description": "Optional service name to resolve. If not provided, the service field of the\nresulting address information structures is left uninitialized.",
					"optional": true
				},
				"hints": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[hints]",
					"description": "Optional hints object that provides additional control over the resolution\nprocess. It can contain the following properties:\n- `family`: The preferred address family (`AF_INET` or `AF_INET6`).\n- `socktype`: The socket type (`SOCK_STREAM`, `SOCK_DGRAM`, etc.).\n- `protocol`: The protocol of returned addresses.\n- `flags`: Bitwise OR-ed `AI_*` flags to control the resolution behavior.",
					"optional": true
				}
			},
			"subject": "Resolves the given hostname and optional service name into a list of network\naddresses, according to the provided hints.",
			"description": "Resolves the given hostname and optional service name into a list of network\naddresses, according to the provided hints.\n\nThe `addrinfo()` function provides an API for performing DNS and service name\nresolution. It returns an array of objects, each representing a resolved\naddress.\n\nReturns an array of resolved addresses.\nReturns `null` if an error occurred during resolution."
		},
		"PollSpec": {
			"kind": "typedef",
			"type": [
				{
					"type": "array"
				}
			],
			"name": "module:socket.PollSpec",
			"subject": "Represents a poll state serving as input parameter and return value type for\n{@link module:socket#poll|`poll()`}.",
			"description": "Represents a poll state serving as input parameter and return value type for\n{@link module:socket#poll|`poll()`}."
		},
		"poll": {
			"kind": "function",
			"name": "module:socket#poll",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "module:socket.PollSpec"
						}
					]
				}
			],
			"params": {
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "timeout",
					"description": "Amount of milliseconds to wait for socket activity before aborting the poll\ncall. If set to `0`, the poll call will return immediately if none of the\nprovided sockets has pending events, if set to a negative value, the poll\ncall will wait indefinitely, in all other cases the poll call will wait at\nmost for the given amount of milliseconds before returning."
				},
				"sockets": {
					"type": [
						{
							"type": "...(module:socket.socket|module:socket.PollSpec)"
						}
					],
					"name": "sockets",
					"description": "An arbitrary amount of socket arguments. Each argument may be either a plain\n{@link module:socket.socket|socket instance} (or any other kind of handle\nimplementing a `fileno()` method) or a `[socket, flags]` tuple specifying the\nsocket and requested poll flags. If a plain socket (or other kind of handle)\ninstead of a tuple is provided, the requested poll flags default to\n`POLLIN|POLLERR|POLLHUP` for this socket."
				}
			},
			"subject": "Polls a number of sockets for state changes.",
			"description": "Polls a number of sockets for state changes.\n\nReturns an array of `[socket, flags]` tuples for each socket with pending\nevents. When a tuple is passed as socket argument, it is included as-is into\nthe result tuple array, with the flags entry changed to a bitwise OR-ed value\ndescribing the pending events for this socket. When a plain socket instance\n(or another kind of handle) is passed, a new tuple array is created for this\nsocket within the result tuple array, containing this socket as first and the\nbitwise OR-ed pending events as second element.\n\nReturns `null` if an error occurred."
		},
		"connect": {
			"kind": "function",
			"name": "module:socket#connect",
			"return": [
				{
					"type": "module:socket.socket"
				}
			],
			"params": {
				"host": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "host",
					"description": "The host to connect to, can be an IP address, hostname,\n{@link module:socket.socket.SocketAddress|SocketAddress}, or an array value\nreturned by {@link module:core#iptoarr|iptoarr()}."
				},
				"service": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "[service]",
					"description": "The service to connect to, can be a symbolic service name (such as \"http\") or\na port number. Optional if host is specified as\n{@link module:socket.socket.SocketAddress|SocketAddress}.",
					"optional": true
				},
				"hints": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[hints]",
					"description": "Optional preferences for the socket. It can contain the following properties:\n- `family`: The preferred address family (`AF_INET` or `AF_INET6`).\n- `socktype`: The socket type (`SOCK_STREAM`, `SOCK_DGRAM`, etc.).\n- `protocol`: The protocol of the created socket.\n- `flags`: Bitwise OR-ed `AI_*` flags to control the resolution behavior.\n\nIf no hints are not provided, the default socket type preference is set to\n`SOCK_STREAM`.",
					"optional": true
				},
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout=-1]",
					"description": "The timeout in milliseconds for socket connect operations. If set to a\nnegative value, no specifc time limit is imposed and the function will\nblock until either a connection was successfull or the underlying operating\nsystem timeout is reached.",
					"default": "-1",
					"optional": true
				}
			},
			"subject": "Creates a network socket and connects it to the specified host and service.",
			"description": "Creates a network socket and connects it to the specified host and service.\n\nThis high level function combines the functionality of\n{@link module:socket#create|create()},\n{@link module:socket#addrinfo|addrinfo()} and\n{@link module:socket.socket#connect|connect()} to simplify connection\nestablishment with the socket module."
		},
		"listen": {
			"kind": "function",
			"name": "module:socket#listen",
			"return": [
				{
					"type": "module:socket.socket"
				}
			],
			"params": {
				"host": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "host",
					"description": "The host to bind to, can be an IP address, hostname,\n{@link module:socket.socket.SocketAddress|SocketAddress}, or an array value\nreturned by {@link module:core#iptoarr|iptoarr()}."
				},
				"service": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "[service]",
					"description": "The service to listen on, can be a symbolic service name (such as \"http\") or\na port number. Optional if host is specified as\n{@link module:socket.socket.SocketAddress|SocketAddress}.",
					"optional": true
				},
				"hints": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[hints]",
					"description": "Optional preferences for the socket. It can contain the following properties:\n- `family`: The preferred address family (`AF_INET` or `AF_INET6`).\n- `socktype`: The socket type (`SOCK_STREAM`, `SOCK_DGRAM`, etc.).\n- `protocol`: The protocol of the created socket.\n- `flags`: Bitwise OR-ed `AI_*` flags to control the resolution behavior.\n\nIf no hints are provided, the default socket type preference is set to\n`SOCK_STREAM`.",
					"optional": true
				},
				"backlog": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[backlog=128]",
					"description": "The maximum length of the queue of pending connections.",
					"default": "128",
					"optional": true
				}
			},
			"subject": "Binds a listening network socket to the specified host and service.",
			"description": "Binds a listening network socket to the specified host and service.\n\nThis high-level function combines the functionality of\n{@link module:socket#create|create()},\n{@link module:socket#addrinfo|addrinfo()},\n{@link module:socket.socket#bind|bind()}, and\n{@link module:socket.socket#listen|listen()} to simplify setting up a\nlistening socket with the socket module."
		},
		"create": {
			"kind": "function",
			"name": "module:socket#create",
			"return": [
				{
					"type": "module:socket.socket",
					"nullable": true
				}
			],
			"description": "Creates a network socket instance.\n\nThis function creates a new network socket with the specified domain and\ntype, determined by one of the modules `AF_*` and `SOCK_*` constants\nrespectively, and returns the resulting socket instance for use in subsequent\nsocket operations.\n\nThe domain argument specifies the protocol family, such as AF_INET or\nAF_INET6, and defaults to AF_INET if not provided.\n\nThe type argument specifies the socket type, such as SOCK_STREAM or\nSOCK_DGRAM, and defaults to SOCK_STREAM if not provided. It may also\nbe bitwise OR-ed with SOCK_NONBLOCK to enable non-blocking mode or\nSOCK_CLOEXEC to enable close-on-exec semantics.\n\nThe protocol argument may be used to indicate a particular protocol\nto be used with the socket, and it defaults to 0 (automatically\ndetermined protocol) if not provided.\n\nReturns a socket descriptor representing the newly created socket.\n\nReturns `null` if an error occurred during socket creation.",
			"params": {
				"domain": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[domain=AF_INET]",
					"description": "The communication domain for the socket, e.g., AF_INET or AF_INET6.",
					"default": "AF_INET",
					"optional": true
				},
				"type": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[type=SOCK_STREAM]",
					"description": "The socket type, e.g., SOCK_STREAM or SOCK_DGRAM. It may also be\nbitwise OR-ed with SOCK_NONBLOCK or SOCK_CLOEXEC.",
					"default": "SOCK_STREAM",
					"optional": true
				},
				"protocol": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[protocol=0]",
					"description": "The protocol to be used with the socket.",
					"default": "0",
					"optional": true
				}
			},
			"subject": "Creates a network socket instance."
		}
	},
	"socket.socket": {
		"setopt": {
			"kind": "function",
			"name": "module:socket.socket#setopt",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "level",
					"description": "The protocol level at which the option resides. This can be a level such as\n`SOL_SOCKET` for the socket API level or a specific protocol level defined\nby the system."
				},
				"option": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "option",
					"description": "The socket option to set. This can be an integer representing the option,\nsuch as `SO_REUSEADDR`, or a constant defined by the system."
				},
				"value": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "value",
					"description": "The value to set the option to. The type of this argument depends on the\nspecific option being set. It can be an integer, a boolean, a string, or a\ndictionary representing the value to set. If a dictionary is provided, it is\ninternally translated to the corresponding C struct type required by the\noption."
				}
			},
			"subject": "Sets options on the socket.",
			"description": "Sets options on the socket.\n\nSets the specified option on the socket to the given value.\n\nReturns `true` if the option was successfully set.\n\nReturns `null` if an error occurred."
		},
		"getopt": {
			"kind": "function",
			"name": "module:socket.socket#getopt",
			"return": [
				{
					"type": "*",
					"nullable": true
				}
			],
			"description": "Gets options from the socket.\n\nRetrieves the value of the specified option from the socket.\n\nReturns the value of the requested option.\n\nReturns `null` if an error occurred or if the option is not supported.",
			"params": {
				"level": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "level",
					"description": "The protocol level at which the option resides. This can be a level such as\n`SOL_SOCKET` for the socket API level or a specific protocol level defined\nby the system."
				},
				"option": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "option",
					"description": "The socket option to retrieve. This can be an integer representing the\noption, such as `SO_REUSEADDR`, or a constant defined by the system."
				}
			},
			"subject": "Gets options from the socket."
		},
		"fileno": {
			"kind": "function",
			"name": "module:socket.socket#fileno",
			"return": [
				{
					"type": "number"
				}
			],
			"subject": "Returns the UNIX file descriptor number associated with the socket.",
			"description": "Returns the UNIX file descriptor number associated with the socket.\n\nReturns the file descriptor number.\n\nReturns `-1` if an error occurred."
		},
		"SocketAddress": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"family": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "family",
							"description": "Address family, one of AF_INET, AF_INET6, AF_UNIX or AF_PACKET."
						},
						"address": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "address",
							"description": "IPv4/IPv6 address string (AF_INET or AF_INET6 only) or hardware address in\nhexadecimal notation (AF_PACKET only)."
						},
						"port": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[port]",
							"description": "Port number (AF_INET or AF_INET6 only)."
						},
						"flowinfo": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[flowinfo]",
							"description": "IPv6 flow information (AF_INET6 only)."
						},
						"interface": {
							"type": [
								{
									"type": "string"
								},
								{
									"type": "number"
								}
							],
							"name": "[interface]",
							"description": "Link local address scope (for IPv6 sockets) or bound network interface\n(for packet sockets), either a network device name string or a nonzero\npositive integer representing a network interface index (AF_INET6 and\nAF_PACKET only)."
						},
						"path": {
							"type": [
								{
									"type": "string"
								}
							],
							"name": "path",
							"description": "Domain socket filesystem path (AF_UNIX only)."
						},
						"protocol": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[protocol=0]",
							"description": "Physical layer protocol (AF_PACKET only)."
						},
						"hardware_type": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[hardware_type=0]",
							"description": "ARP hardware type (AF_PACKET only)."
						},
						"packet_type": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "[packet_type=PACKET_HOST]",
							"description": "Packet type (AF_PACKET only)."
						}
					}
				}
			],
			"name": "module:socket.socket.SocketAddress",
			"optional": true,
			"default": "PACKET_HOST",
			"description": ""
		},
		"connect": {
			"kind": "function",
			"name": "module:socket.socket#connect",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"address": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "address",
					"description": "The address of the remote endpoint to connect to."
				},
				"port": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "port",
					"description": "The port number of the remote endpoint to connect to."
				}
			},
			"subject": "Connects the socket to a remote address.",
			"description": "Connects the socket to a remote address.\n\nAttempts to establish a connection to the specified remote address.\n\nReturns `true` if the connection is successfully established.\nReturns `null` if an error occurred during the connection attempt."
		},
		"send": {
			"kind": "function",
			"name": "module:socket.socket#send",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"params": {
				"data": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "data",
					"description": "The data to be sent through the socket. String data is sent as-is, any other\ntype is implicitly converted to a string first before being sent on the\nsocket."
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags that modify the behavior of the send operation.",
					"optional": true
				},
				"address": {
					"type": [
						{
							"type": "module:socket.socket.SocketAddress"
						},
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						},
						{
							"type": "string"
						}
					],
					"name": "[address]",
					"description": "The address of the remote endpoint to send the data to. It can be either an\nIP address string, an array returned by {@link module:core#iptoarr|iptoarr()},\nor an object representing a network address. If not provided, the data is\nsent to the remote endpoint the socket is connected to.",
					"optional": true
				}
			},
			"subject": "Sends data through the socket.",
			"description": "Sends data through the socket.\n\nSends the provided data through the socket handle to the specified remote\naddress, if provided.\n\nReturns the number of bytes sent.\nReturns `null` if an error occurred during the send operation."
		},
		"recv": {
			"kind": "function",
			"name": "module:socket.socket#recv",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"length": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[length=4096]",
					"description": "The maximum number of bytes to receive.",
					"default": "4096",
					"optional": true
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags that modify the behavior of the receive operation.",
					"optional": true
				},
				"address": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[address]",
					"description": "An object where the function will store the address from which the data was\nreceived. If provided, it will be filled with the details obtained from the\nsockaddr argument of the underlying `recvfrom()` syscall. See the type\ndefinition of {@link module:socket.socket.SocketAddress|SocketAddress} for\ndetails on the format.",
					"optional": true
				}
			},
			"subject": "Receives data from the socket.",
			"description": "Receives data from the socket.\n\nReceives data from the socket handle, optionally specifying the maximum\nlength of data to receive, flags to modify the receive behavior, and an\noptional address dictionary where the function will place the address from\nwhich the data was received (for unconnected sockets).\n\nReturns a string containing the received data.\nReturns an empty string if the remote side closed the socket.\nReturns `null` if an error occurred during the receive operation."
		},
		"ControlMessage": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"level": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "level",
							"description": "The message socket level (`cmsg_level`), e.g. `SOL_SOCKET`."
						},
						"type": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "type",
							"description": "The protocol specific message type (`cmsg_type`), e.g. `SCM_RIGHTS`."
						},
						"data": {
							"type": [
								{
									"type": "*"
								}
							],
							"name": "data",
							"description": "The payload of the control message. If the control message type is known by\nthe socket module, it is represented as a mixed value (array, object, number,\netc.) with structure specific to the control message type. If the control\nmessage cannot be decoded, *data* is set to a string value containing the raw\npayload."
						}
					}
				}
			],
			"name": "module:socket.socket.ControlMessage",
			"subject": "Represents a single control (ancillary data) message returned\nin the *ancillary* array by {@link module:socket.socket#recvmsg|`recvmsg()`}.",
			"description": "Represents a single control (ancillary data) message returned\nin the *ancillary* array by {@link module:socket.socket#recvmsg|`recvmsg()`}."
		},
		"sendmsg": {
			"kind": "function",
			"name": "module:socket.socket#sendmsg",
			"return": [
				{
					"type": "number",
					"nullable": true
				}
			],
			"description": "Sends a message through the socket.\n\nSends a message through the socket handle, supporting complex message\nstructures including multiple data buffers and ancillary data. This function\nallows for precise control over the message content and delivery behavior.\n\nReturns the number of sent bytes.\n\nReturns `null` if an error occurred.",
			"params": {
				"data": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "[data]",
					"description": "The data to be sent. If a string is provided, it is sent as is. If an array\nis specified, each item is sent as a separate `struct iovec`. Non-string\nvalues are implicitly converted to a string and sent. If omitted, only\nancillary data and address are considered.",
					"optional": true
				},
				"ancillaryData": {
					"type": [
						{
							"type": "array",
							"itemtype": [
								{
									"type": "module:socket.socket.ControlMessage"
								}
							]
						},
						{
							"type": "string"
						}
					],
					"name": "[ancillaryData]",
					"description": "Optional ancillary data to be sent. If an array is provided, each element is\nconverted to a control message. If a string is provided, it is sent as-is\nwithout further interpretation. Refer to\n{@link module:socket.socket#recvmsg|`recvmsg()`} and\n{@link module:socket.socket.ControlMessage|ControlMessage} for details.",
					"optional": true
				},
				"address": {
					"type": [
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "[address]",
					"description": "The destination address for the message. If provided, it sets or overrides\nthe packet destination address.",
					"optional": true
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags to modify the behavior of the send operation. This should be a\nbitwise OR-ed combination of `MSG_*` flag values.",
					"optional": true
				}
			},
			"subject": "Sends a message through the socket."
		},
		"ReceivedMessage": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"flags": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "flags",
							"description": "Integer value containing bitwise OR-ed `MSG_*` result flags returned by the\nunderlying receive call."
						},
						"length": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "length",
							"description": "Integer value containing the number of bytes returned by the `recvmsg()`\nsyscall, which might be larger than the received data in case `MSG_TRUNC`\nwas passed."
						},
						"address": {
							"type": [
								{
									"type": "module:socket.socket.SocketAddress"
								}
							],
							"name": "address",
							"description": "The address from which the message was received."
						},
						"data": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "string"
										}
									]
								},
								{
									"type": "string"
								}
							],
							"name": "data",
							"description": "An array of strings, each representing the received message data.\nEach string corresponds to one buffer size specified in the *sizes* argument.\nIf a single receive size was passed instead of an array of sizes, *data* will\nhold a string containing the received data."
						},
						"ancillary": {
							"type": [
								{
									"type": "array",
									"itemtype": [
										{
											"type": "module:socket.socket.ControlMessage"
										}
									]
								}
							],
							"name": "[ancillary]",
							"description": "An array of received control messages. Only included if a non-zero positive\n*ancillarySize* was passed to `recvmsg()`."
						}
					}
				}
			],
			"name": "module:socket.socket.ReceivedMessage",
			"optional": true,
			"subject": "Represents a message object returned by\n{@link module:socket.socket#recvmsg|`recvmsg()`}.",
			"description": "Represents a message object returned by\n{@link module:socket.socket#recvmsg|`recvmsg()`}."
		},
		"recvmsg": {
			"kind": "function",
			"name": "module:socket.socket#recvmsg",
			"return": [
				{
					"type": "module:socket.socket.ReceivedMessage",
					"nullable": true
				}
			],
			"description": "Receives a message from the socket.\n\nReceives a message from the socket handle, allowing for more complex data\nreception compared to `recv()`. This includes the ability to receive\nancillary data (such as file descriptors, credentials, etc.), multiple\nmessage segments, and optional flags to modify the receive behavior.\n\nReturns an object containing the received message data, ancillary data,\nand the sender's address.\n\nReturns `null` if an error occurred during the receive operation.",
			"params": {
				"sizes": {
					"type": [
						{
							"type": "array",
							"itemtype": [
								{
									"type": "number"
								}
							]
						},
						{
							"type": "number"
						}
					],
					"name": "[sizes]",
					"description": "Specifies the sizes of the buffers used for receiving the message. If an\narray of numbers is provided, each number determines the size of an\nindividual buffer segment, creating multiple `struct iovec` for reception.\nIf a single number is provided, a single buffer of that size is used.",
					"optional": true
				},
				"ancillarySize": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[ancillarySize]",
					"description": "The size allocated for the ancillary data buffer. If not provided, ancillary\ndata is not processed.",
					"optional": true
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags to modify the behavior of the receive operation. This should\nbe a bitwise OR-ed combination of flag values.",
					"optional": true
				}
			},
			"subject": "Receives a message from the socket."
		},
		"bind": {
			"kind": "function",
			"name": "module:socket.socket#bind",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"address": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "module:socket.socket.SocketAddress"
						}
					],
					"name": "address",
					"description": "The IP address to bind the socket to."
				}
			},
			"subject": "Binds a socket to a specific address.",
			"description": "Binds a socket to a specific address.\n\nThis function binds the socket to the specified address.\n\nReturns `true` if the socket is successfully bound.\n\nReturns `null` on error, e.g. when the address is in use."
		},
		"listen": {
			"kind": "function",
			"name": "module:socket.socket#listen",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"backlog": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[backlog=128]",
					"description": "The maximum length of the queue of pending connections.",
					"default": "128",
					"optional": true
				}
			},
			"subject": "Listen for connections on a socket.",
			"description": "Listen for connections on a socket.\n\nThis function marks the socket as a passive socket, that is, as a socket that\nwill be used to accept incoming connection requests using `accept()`.\n\nThe `backlog` parameter specifies the maximum length to which the queue of\npending connections may grow. If a connection request arrives when the queue\nis full, the client connection might get refused.\n\nIf `backlog` is not provided, it defaults to 128.\n\nReturns `true` if the socket is successfully marked as passive.\nReturns `null` if an error occurred, e.g. when the requested port is in use."
		},
		"accept": {
			"kind": "function",
			"name": "module:socket.socket#accept",
			"return": [
				{
					"type": "module:socket.socket",
					"nullable": true
				}
			],
			"params": {
				"address": {
					"type": [
						{
							"type": "object"
						}
					],
					"name": "[address]",
					"description": "An optional dictionary to receive the address details of the peer socket.\nSee {@link module:socket.socket.SocketAddress|SocketAddress} for details.",
					"optional": true
				},
				"flags": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[flags]",
					"description": "Optional flags to modify the behavior of the peer socket.",
					"optional": true
				}
			},
			"subject": "Accept a connection on a socket.",
			"description": "Accept a connection on a socket.\n\nThis function accepts a connection on the socket. It extracts the first\nconnection request on the queue of pending connections, creates a new\nconnected socket, and returns a new socket handle referring to that socket.\nThe newly created socket is not in listening state and has no backlog.\n\nWhen a optional `address` dictionary is provided, it is populated with the\nremote address details of the peer socket.\n\nThe optional `flags` parameter is a bitwise-or-ed number of flags to modify\nthe behavior of accepted peer socket. Possible values are:\n- `SOCK_CLOEXEC`: Enable close-on-exec semantics for the new socket.\n- `SOCK_NONBLOCK`: Enable nonblocking mode for the new socket.\n\nReturns a socket handle representing the newly created peer socket of the\naccepted connection.\n\nReturns `null` if an error occurred."
		},
		"shutdown": {
			"kind": "function",
			"name": "module:socket.socket#shutdown",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"how": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "how",
					"description": "Specifies which half of the connection to shut down.\nIt can be one of the following constant values: `SHUT_RD`, `SHUT_WR`,\nor `SHUT_RDWR`."
				}
			},
			"subject": "Shutdown part of a full-duplex connection.",
			"description": "Shutdown part of a full-duplex connection.\n\nThis function shuts down part of the full-duplex connection associated with\nthe socket handle. The `how` parameter specifies which half of the connection\nto shut down. It can take one of the following constant values:\n\n- `SHUT_RD`: Disables further receive operations.\n- `SHUT_WR`: Disables further send operations.\n- `SHUT_RDWR`: Disables further send and receive operations.\n\nReturns `true` if the shutdown operation is successful.\nReturns `null` if an error occurred."
		},
		"PeerCredentials": {
			"kind": "typedef",
			"type": [
				{
					"type": "object",
					"properties": {
						"uid": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "uid",
							"description": "The effective user ID the remote socket endpoint."
						},
						"gid": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "gid",
							"description": "The effective group ID the remote socket endpoint."
						},
						"pid": {
							"type": [
								{
									"type": "number"
								}
							],
							"name": "pid",
							"description": "The ID of the process the remote socket endpoint belongs to."
						}
					}
				}
			],
			"name": "module:socket.socket.PeerCredentials",
			"subject": "Represents a credentials information object returned by\n{@link module:socket.socket#peercred|`peercred()`}.",
			"description": "Represents a credentials information object returned by\n{@link module:socket.socket#peercred|`peercred()`}."
		},
		"peercred": {
			"kind": "function",
			"name": "module:socket.socket#peercred",
			"return": [
				{
					"type": "module:socket.socket.PeerCredentials",
					"nullable": true
				}
			],
			"subject": "Retrieves the peer credentials.",
			"description": "Retrieves the peer credentials.\n\nThis function retrieves the remote uid, gid and pid of a connected UNIX\ndomain socket.\n\nReturns the remote credentials if the operation is successful.\nReturns `null` on error."
		},
		"peername": {
			"kind": "function",
			"name": "module:socket.socket#peername",
			"return": [
				{
					"type": "module:socket.socket.SocketAddress",
					"nullable": true
				}
			],
			"subject": "Retrieves the remote address.",
			"description": "Retrieves the remote address.\n\nThis function retrieves the remote address of a connected socket.\n\nReturns the remote address if the operation is successful.\nReturns `null` on error."
		},
		"sockname": {
			"kind": "function",
			"name": "module:socket.socket#sockname",
			"return": [
				{
					"type": "module:socket.socket.SocketAddress",
					"nullable": true
				}
			],
			"subject": "Retrieves the local address.",
			"description": "Retrieves the local address.\n\nThis function retrieves the local address of a bound or connected socket.\n\nReturns the local address if the operation is successful.\nReturns `null` on error."
		},
		"close": {
			"kind": "function",
			"name": "module:socket.socket#close",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"subject": "Closes the socket.",
			"description": "Closes the socket.\n\nThis function closes the socket, releasing its resources and terminating its\nassociated connections.\n\nReturns `true` if the socket was successfully closed.\nReturns `null` on error."
		}
	},
	"struct": {
		"pack": {
			"kind": "function",
			"name": "module:struct#pack",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "format",
					"description": "The format string."
				},
				"values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "values",
					"description": "Variable number of values to pack."
				}
			},
			"subject": "Pack given values according to specified format.",
			"description": "Pack given values according to specified format.\n\nThe `pack()` function creates a byte string containing the argument values\npacked according to the given format string.\n\nReturns the packed string.\n\nRaises a runtime exception if a given argument value does not match the\nrequired type of the corresponding format string directive or if and invalid\nformat string is provided."
		},
		"unpack": {
			"kind": "function",
			"name": "module:struct#unpack",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "format",
					"description": "The format string."
				},
				"input": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "input",
					"description": "The input string to unpack."
				},
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[offset=0]",
					"description": "The offset within the input string to start unpacking from.",
					"default": "0",
					"optional": true
				}
			},
			"subject": "Unpack given byte string according to specified format.",
			"description": "Unpack given byte string according to specified format.\n\nThe `unpack()` function interpretes a byte string according to the given\nformat string and returns the resulting values. If the optional offset\nargument is given, unpacking starts from this byte position within the input.\nIf not specified, the start offset defaults to `0`, the start of the given\ninput string.\n\nReturns an array of unpacked values.\n\nRaises a runtime exception if the format string is invalid or if an invalid\ninput string or offset value is given."
		},
		"new": {
			"kind": "function",
			"name": "module:struct#new",
			"return": [
				{
					"type": "module:struct.instance"
				}
			],
			"params": {
				"format": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "format",
					"description": "The format string."
				}
			},
			"subject": "Precompile format string.",
			"description": "Precompile format string.\n\nThe `new()` function precompiles the given format string argument and returns\na `struct` object instance useful for packing and unpacking multiple items\nwithout having to recompute the internal format each time.\n\nReturns an precompiled struct format instance.\n\nRaises a runtime exception if the format string is invalid."
		},
		"buffer": {
			"kind": "function",
			"name": "module:struct#buffer",
			"return": [
				{
					"type": "module:struct.buffer"
				}
			],
			"params": {
				"initialData": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[initialData]",
					"description": "Optional initial data to populate the buffer with.",
					"optional": true
				}
			},
			"subject": "Creates a new struct buffer instance.",
			"description": "Creates a new struct buffer instance.\n\nThe `buffer()` function creates a new struct buffer object that can be used\nfor incremental packing and unpacking of binary data. If an initial data\nstring is provided, the buffer is initialized with this content.\n\nNote that even when initial data is provided, the buffer position is always\nset to zero. This design assumes that the primary intent when initializing\na buffer with data is to read (unpack) from the beginning. If you want to\nappend data to a pre-initialized buffer, you need to explicitly move the\nposition to the end, either by calling `end()` or by setting the position\nmanually with `pos()`.\n\nReturns a new struct buffer instance."
		}
	},
	"struct.instance": {
		"pack": {
			"kind": "function",
			"name": "module:struct.instance#pack",
			"return": [
				{
					"type": "string"
				}
			],
			"params": {
				"values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "values",
					"description": "Variable number of values to pack."
				}
			},
			"subject": "Pack given values.",
			"description": "Pack given values.\n\nThe `pack()` function creates a byte string containing the argument values\npacked according to the given format instance.\n\nReturns the packed string.\n\nRaises a runtime exception if a given argument value does not match the\nrequired type of the corresponding format string directive."
		},
		"unpack": {
			"kind": "function",
			"name": "module:struct.instance#unpack",
			"return": [
				{
					"type": "array"
				}
			],
			"params": {
				"input": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "input",
					"description": "The input string to unpack."
				},
				"offset": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[offset=0]",
					"description": "The offset within the input string to start unpacking from.",
					"default": "0",
					"optional": true
				}
			},
			"subject": "Unpack given byte string.",
			"description": "Unpack given byte string.\n\nThe `unpack()` function interpretes a byte string according to the given\nformat instance and returns the resulting values. If the optional offset\nargument is given, unpacking starts from this byte position within the input.\nIf not specified, the start offset defaults to `0`, the start of the given\ninput string.\n\nReturns an array of unpacked values.\n\nRaises a runtime exception if an invalid input string or offset value is\ngiven."
		}
	},
	"struct.buffer": {
		"pos": {
			"kind": "function",
			"name": "module:struct.buffer#pos",
			"return": [
				{
					"type": "number"
				},
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Get or set the current position in the buffer.\n\nIf called without arguments, returns the current position.\nIf called with a position argument, sets the current position to that value.",
			"params": {
				"position": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[position]",
					"description": "The position to set. If omitted, the current position is returned.",
					"optional": true
				}
			},
			"subject": "Get or set the current position in the buffer."
		},
		"length": {
			"kind": "function",
			"name": "module:struct.buffer#length",
			"return": [
				{
					"type": "number"
				},
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Get or set the current buffer length.\n\nIf called without arguments, returns the current length of the buffer.\nIf called with a length argument, sets the buffer length to that value,\npadding the data with trailing zero bytes or truncating it depending on\nwhether the updated length is larger or smaller than the current length\nrespectively.\n\nIn case the updated length is smaller than the current buffer offset, the\nposition is updated accordingly, so that it points to the new end of the\ntruncated buffer data.",
			"params": {
				"length": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[length]",
					"description": "The length to set. If omitted, the current length is returned.",
					"optional": true
				}
			},
			"subject": "Get or set the current buffer length."
		},
		"start": {
			"kind": "function",
			"name": "module:struct.buffer#start",
			"return": [
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Set the buffer position to the start (0).",
			"subject": "Set the buffer position to the start (0)."
		},
		"end": {
			"kind": "function",
			"name": "module:struct.buffer#end",
			"return": [
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Set the buffer position to the end.",
			"subject": "Set the buffer position to the end."
		},
		"put": {
			"kind": "function",
			"name": "module:struct.buffer#put",
			"return": [
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Pack data into the buffer at the current position.\n\nThe `put()` function packs the given values into the buffer according to\nthe specified format string, starting at the current buffer position.\nThe format string follows the same syntax as used in `struct.pack()`.\n\nFor a detailed explanation of the format string syntax, refer to the\n[\"Format Strings\" section]{@link module:struct} in the module\ndocumentation.",
			"params": {
				"format": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "format",
					"description": "The format string specifying how to pack the data."
				},
				"values": {
					"type": [
						{
							"type": "...*"
						}
					],
					"name": "values",
					"description": "The values to pack into the buffer."
				}
			},
			"subject": "Pack data into the buffer at the current position."
		},
		"get": {
			"kind": "function",
			"name": "module:struct.buffer#get",
			"return": [
				{
					"type": "array"
				}
			],
			"description": "Unpack multiple values from the buffer at the current position.\n\nThe `read()` function unpacks multiple values from the buffer according to\nthe specified format string, starting at the current buffer position.\nThe format string follows the same syntax as used in `struct.unpack()`.\n\nFor a detailed explanation of the format string syntax, refer to the\n[\"Format Strings\" section]{@link module:struct} in the module documentation.",
			"params": {
				"format": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "format",
					"description": "The format string specifying how to unpack the data."
				}
			},
			"subject": "Unpack multiple values from the buffer at the current position."
		},
		"slice": {
			"kind": "function",
			"name": "module:struct.buffer#slice",
			"return": [
				{
					"type": "string"
				}
			],
			"description": "Extract a slice of the buffer content.\n\nThe `slice()` function returns a substring of the buffer content\nbetween the specified start and end positions.\n\nBoth the start and end position values may be negative, in which case they're\nrelative to the end of the buffer, e.g. `slice(-3)` will extract the last\nthree bytes of data.",
			"params": {
				"start": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[start=0]",
					"description": "The starting position of the slice.",
					"default": "0",
					"optional": true
				},
				"end": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[end=buffer.length()]",
					"description": "The ending position of the slice (exclusive).",
					"default": "buffer.length()",
					"optional": true
				}
			},
			"subject": "Extract a slice of the buffer content."
		},
		"set": {
			"kind": "function",
			"name": "module:struct.buffer#set",
			"return": [
				{
					"type": "module:struct.buffer"
				}
			],
			"description": "Set a slice of the buffer content to given byte value.\n\nThe `set()` function overwrites a substring of the buffer content with the\ngiven byte value, similar to the C `memset()` function, between the specified\nstart and end positions.\n\nBoth the start and end position values may be negative, in which case they're\nrelative to the end of the buffer, e.g. `set(0, -2)` will overwrite the last\ntwo bytes of data with `\\x00`.\n\nWhen the start or end positions are beyond the current buffer length, the\nbuffer is grown accordingly.",
			"params": {
				"value": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "string"
						}
					],
					"name": "[value=0]",
					"description": "The byte value to use when overwriting buffer contents. When a string is\ngiven, the first character is used as value.",
					"default": "0",
					"optional": true
				},
				"start": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[start=0]",
					"description": "The position to start overwriting from.",
					"default": "0",
					"optional": true
				},
				"end": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[end=buffer.length()]",
					"description": "The position to end overwriting (exclusive).",
					"default": "buffer.length()",
					"optional": true
				}
			},
			"subject": "Set a slice of the buffer content to given byte value."
		},
		"pull": {
			"kind": "function",
			"name": "module:struct.buffer#pull",
			"return": [
				{
					"type": "string"
				}
			],
			"description": "Extract and remove all content from the buffer.\n\nThe `pull()` function returns all content of the buffer as a string\nand resets the buffer to an empty state.",
			"subject": "Extract and remove all content from the buffer."
		}
	},
	"uci": {
		"error": {
			"kind": "function",
			"name": "module:uci#error",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"subject": "Query error information.",
			"description": "Query error information.\n\nReturns a string containing a description of the last occurred error or\n`null` if there is no error information."
		},
		"cursor": {
			"kind": "function",
			"name": "module:uci#cursor",
			"return": [
				{
					"type": "module:uci.cursor",
					"nullable": true
				}
			],
			"params": {
				"config_dir": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[config_dir=/etc/config]",
					"description": "The directory to search for configuration files. It defaults to the well\nknown uci configuration directory `/etc/config` but may be set to a different\npath for special purpose applications.",
					"default": "/etc/config",
					"optional": true
				},
				"delta_dir": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[delta_dir=/tmp/.uci]",
					"description": "The directory to save delta records in. It defaults to the well known\n`/tmp/.uci` path which is used as default by the uci command line tool.\n\nBy changing this path to a different location, it is possible to isolate\nuncommitted application changes from the uci cli or other processes on the\nsystem.",
					"default": "/tmp/.uci",
					"optional": true
				}
			},
			"subject": "Instantiate uci cursor.",
			"description": "Instantiate uci cursor.\n\nA uci cursor is a context for interacting with uci configuration files. It's\npurpose is to cache and hold changes made to loaded configuration states\nuntil those changes are written out to disk or discared.\n\nUnsaved and uncommitted changes in a cursor instance are private and not\nvisible to other cursor instances instantiated by the same program or other\nprocesses on the system.\n\nReturns the instantiated cursor on success.\n\nReturns `null` on error, e.g. if an invalid path argument was provided."
		}
	},
	"uci.cursor": {
		"load": {
			"kind": "function",
			"name": "module:uci.cursor#load",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to load, e.g. `\"system\"` to load\n`/etc/config/system` into the cursor."
				}
			},
			"subject": "Explicitly reload configuration file.",
			"description": "Explicitly reload configuration file.\n\nUsually, any attempt to query or modify a value within a given configuration\nwill implicitly load the underlying file into memory. By invoking `load()`\nexplicitly, a potentially loaded stale configuration is discarded and\nreloaded from the file system, ensuring that the latest state is reflected in\nthe cursor.\n\nReturns `true` if the configuration was successfully loaded.\n\nReturns `null` on error, e.g. if the requested configuration does not exist."
		},
		"unload": {
			"kind": "function",
			"name": "module:uci.cursor#unload",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to unload."
				}
			},
			"subject": "Explicitly unload configuration file.",
			"description": "Explicitly unload configuration file.\n\nThe `unload()` function forcibly discards a loaded configuration state from\nthe cursor so that the next attempt to read or modify that configuration\nwill load it anew from the file system.\n\nReturns `true` if the configuration was successfully unloaded.\n\nReturns `false` if the configuration was not loaded to begin with.\n\nReturns `null` on error, e.g. if the requested configuration does not exist."
		},
		"get": {
			"kind": "function",
			"name": "module:uci.cursor#get",
			"return": [
				{
					"type": "(string|string[])",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to query, e.g. `\"system\"` to query values\nin `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "section",
					"description": "The name of the section to query within the configuration."
				},
				"option": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[option]",
					"description": "The name of the option to query within the section. If omitted, the type of\nthe section is returned instead.",
					"optional": true
				}
			},
			"subject": "Query a single option value or section type.",
			"description": "Query a single option value or section type.\n\nWhen invoked with three arguments, the function returns the value of the\ngiven option, within the specified section of the given configuration.\n\nWhen invoked with just a config and section argument, the function returns\nthe type of the specified section.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the configuration value or section type on success.\n\nReturns `null` on error, e.g. if the requested configuration does not exist\nor if an invalid argument was passed."
		},
		"get_all": {
			"kind": "function",
			"name": "module:uci.cursor#get_all",
			"return": [
				{
					"type": "(Object<string, module:uci.cursor.SectionObject>|module:uci.cursor.SectionObject)",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to query, e.g. `\"system\"` to query values\nin `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[section]",
					"description": "The name of the section to query within the configuration. If omitted a\nnested dictionary containing all section values is returned.",
					"optional": true
				}
			},
			"subject": "Query a complete section or configuration.",
			"description": "Query a complete section or configuration.\n\nWhen invoked with two arguments, the function returns all values of the\nspecified section within the given configuration as dictionary.\n\nWhen invoked with just a config argument, the function returns a nested\ndictionary of all sections present within the given configuration.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the section or configuration dictionary on success.\n\nReturns `null` on error, e.g. if the requested configuration does not exist\nor if an invalid argument was passed."
		},
		"get_first": {
			"kind": "function",
			"name": "module:uci.cursor#get_first",
			"return": [
				{
					"type": "(string|string[])",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to query, e.g. `\"system\"` to query values\nin `/etc/config/system`."
				},
				"type": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "type",
					"description": "The section type to find the first section for within the configuration."
				},
				"option": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[option]",
					"description": "The name of the option to query within the section. If omitted, the name of\nthe section is returned instead.",
					"optional": true
				}
			},
			"subject": "Query option value or name of first section of given type.",
			"description": "Query option value or name of first section of given type.\n\nWhen invoked with three arguments, the function returns the value of the\ngiven option within the first found section of the specified type in the\ngiven configuration.\n\nWhen invoked with just a config and section type argument, the function\nreturns the name of the first found section of the given type.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the configuration value or section name on success.\n\nReturns `null` on error, e.g. if the requested configuration does not exist\nor if an invalid argument was passed."
		},
		"add": {
			"kind": "function",
			"name": "module:uci.cursor#add",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to add the section to, e.g. `\"system\"` to\nmodify `/etc/config/system`."
				},
				"type": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "type",
					"description": "The type value to use for the added section."
				}
			},
			"subject": "Add anonymous section to given configuration.",
			"description": "Add anonymous section to given configuration.\n\nAdds a new anonymous (unnamed) section of the specified type to the given\nconfiguration. In order to add a named section, the three argument form of\n`set()` should be used instead.\n\nIn contrast to other query functions, `add()` will not implicitly load the\nconfiguration into the cursor. The configuration either needs to be loaded\nexplicitly through `load()` beforehand, or implicitly by querying it through\none of the `get()`, `get_all()`, `get_first()` or `foreach()` functions.\n\nReturns the autogenerated, ephemeral name of the added unnamed section\non success.\n\nReturns `null` on error, e.g. if the targeted configuration was not loaded or\nif an invalid section type value was passed."
		},
		"set": {
			"kind": "function",
			"name": "module:uci.cursor#set",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to set values in, e.g. `\"system\"` to\nmodify `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "section",
					"description": "The section name to create or set a value in."
				},
				"option_or_type": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "option_or_type",
					"description": "The option name to set within the section or, when the subsequent value\nargument is omitted, the type of the section to create within the\nconfiguration."
				},
				"value": {
					"type": [
						{
							"type": "Array<string|boolean|number>"
						},
						{
							"type": "string"
						},
						{
							"type": "boolean"
						},
						{
							"type": "number"
						}
					],
					"name": "[value]",
					"description": "The option value to set.",
					"optional": true
				}
			},
			"subject": "Set option value or add named section in given configuration.",
			"description": "Set option value or add named section in given configuration.\n\nWhen invoked with four arguments, the function sets the value of the given\noption within the specified section of the given configuration to the\nprovided value. A value of `\"\"` (empty string) can be used to delete an\nexisting option.\n\nWhen invoked with three arguments, the function adds a new named section to\nthe given configuration, using the specified type.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the `true` if the named section was added or the specified option was\nset.\n\nReturns `null` on error, e.g. if the targeted configuration was not found or\nif an invalid value was passed."
		},
		"delete": {
			"kind": "function",
			"name": "module:uci.cursor#delete",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to delete values in, e.g. `\"system\"` to\nmodify `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "section",
					"description": "The section name to remove the specified option in or, when the subsequent\nargument is omitted, the section to remove entirely."
				},
				"option": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[option]",
					"description": "The option name to remove within the section.",
					"optional": true
				}
			},
			"subject": "Delete an option or section from given configuration.",
			"description": "Delete an option or section from given configuration.\n\nWhen invoked with three arguments, the function deletes the given option\nwithin the specified section of the given configuration.\n\nWhen invoked with two arguments, the function deletes the entire specified\nsection within the given configuration.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the `true` if specified option or section has been deleted.\n\nReturns `null` on error, e.g. if the targeted configuration was not found or\nif an invalid value was passed."
		},
		"rename": {
			"kind": "function",
			"name": "module:uci.cursor#rename",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to rename values in, e.g. `\"system\"` to\nmodify `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "section",
					"description": "The section name to rename or to rename an option in."
				},
				"option_or_name": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "option_or_name",
					"description": "The option name to rename within the section or, when the subsequent name\nargument is omitted, the new name of the renamed section within the\nconfiguration."
				},
				"name": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[name]",
					"description": "The new name of the option to rename.",
					"optional": true
				}
			},
			"subject": "Rename an option or section in given configuration.",
			"description": "Rename an option or section in given configuration.\n\nWhen invoked with four arguments, the function renames the given option\nwithin the specified section of the given configuration to the provided\nvalue.\n\nWhen invoked with three arguments, the function renames the entire specified\nsection to the provided value.\n\nIn either case, the given configuration is implicitly loaded into the cursor\nif not already present.\n\nReturns the `true` if specified option or section has been renamed.\n\nReturns `null` on error, e.g. if the targeted configuration was not found or\nif an invalid value was passed."
		},
		"reorder": {
			"kind": "function",
			"name": "module:uci.cursor#reorder",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The name of the configuration file to move the section in, e.g. `\"system\"` to\nmodify `/etc/config/system`."
				},
				"section": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "section",
					"description": "The section name to move."
				},
				"index": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "index",
					"description": "The target index to move the section to, starting from `0`."
				}
			},
			"subject": "Reorder sections in given configuration.",
			"description": "Reorder sections in given configuration.\n\nThe `reorder()` function moves a single section by repositioning it to the\ngiven index within the configurations section list.\n\nThe given configuration is implicitly loaded into the cursor if not already\npresent.\n\nReturns the `true` if specified section has been moved.\n\nReturns `null` on error, e.g. if the targeted configuration was not found or\nif an invalid value was passed."
		},
		"save": {
			"kind": "function",
			"name": "module:uci.cursor#save",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[config]",
					"description": "The name of the configuration file to save delta records for, e.g. `\"system\"`\nto store changes for `/etc/config/system`.",
					"optional": true
				}
			},
			"subject": "Save accumulated cursor changes to delta directory.",
			"description": "Save accumulated cursor changes to delta directory.\n\nThe `save()` function writes consolidated changes made to in-memory copies of\nloaded configuration files to the uci delta directory which effectively makes\nthem available to other processes using the same delta directory path as well\nas the `uci changes` cli command when using the default delta directory.\n\nNote that uci deltas are overlayed over the actual configuration file values\nso they're reflected by `get()`, `foreach()` etc. even if the underlying\nconfiguration files are not actually changed (yet). The delta records may be\neither permanently merged into the configuration by invoking `commit()` or\nreverted through `revert()` in order to restore the current state of the\nunderlying configuration file.\n\nWhen the optional \"config\" parameter is omitted, delta records for all\ncurrently loaded configuration files are written.\n\nIn case that neither sharing changes with other processes nor any revert\nfunctionality is required, changes may be committed directly using `commit()`\ninstead, bypassing any delta record creation.\n\nReturns the `true` if operation completed successfully.\n\nReturns `null` on error, e.g. if the requested configuration was not loaded\nor when a file system error occurred."
		},
		"commit": {
			"kind": "function",
			"name": "module:uci.cursor#commit",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[config]",
					"description": "The name of the configuration file to commit, e.g. `\"system\"` to update the\n`/etc/config/system` file.",
					"optional": true
				}
			},
			"subject": "Update configuration files with accumulated cursor changes.",
			"description": "Update configuration files with accumulated cursor changes.\n\nThe `commit()` function merges changes made to in-memory copies of loaded\nconfiguration files as well as existing delta records in the cursors\nconfigured delta directory and writes them back into the underlying\nconfiguration files, persistently committing changes to the file system.\n\nWhen the optional \"config\" parameter is omitted, all currently loaded\nconfiguration files with either present delta records or yet unsaved\ncursor changes are updated.\n\nReturns the `true` if operation completed successfully.\n\nReturns `null` on error, e.g. if the requested configuration was not loaded\nor when a file system error occurred."
		},
		"revert": {
			"kind": "function",
			"name": "module:uci.cursor#revert",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[config]",
					"description": "The name of the configuration file to revert, e.g. `\"system\"` to discard any\nchanges for the `/etc/config/system` file.",
					"optional": true
				}
			},
			"subject": "Revert accumulated cursor changes and associated delta records.",
			"description": "Revert accumulated cursor changes and associated delta records.\n\nThe `revert()` function discards any changes made to in-memory copies of\nloaded configuration files and discards any related existing delta records in\nthe  cursors configured delta directory.\n\nWhen the optional \"config\" parameter is omitted, all currently loaded\nconfiguration files with either present delta records or yet unsaved\ncursor changes are reverted.\n\nReturns the `true` if operation completed successfully.\n\nReturns `null` on error, e.g. if the requested configuration was not loaded\nor when a file system error occurred."
		},
		"changes": {
			"kind": "function",
			"name": "module:uci.cursor#changes",
			"return": [
				{
					"type": "object",
					"keytype": [
						{
							"type": "string"
						}
					],
					"itemtype": [
						{
							"type": "array",
							"itemtype": [
								{
									"type": "module:uci.cursor.ChangeRecord"
								}
							]
						}
					],
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "[config]",
					"description": "The name of the configuration file to enumerate changes for, e.g. `\"system\"`\nto query pending changes for the `/etc/config/system` file.",
					"optional": true
				}
			},
			"subject": "Enumerate pending changes.",
			"description": "Enumerate pending changes.\n\nThe `changes()` function returns a list of change records for currently\nloaded configuration files, originating both from the cursors associated\ndelta directory and yet unsaved cursor changes.\n\nWhen the optional \"config\" parameter is specified, the requested\nconfiguration is implicitly loaded if it is not already loaded into the\ncursor.\n\nReturns a dictionary of change record arrays, keyed by configuration name.\n\nReturns `null` on error, e.g. if the requested configuration could not be\nloaded."
		},
		"foreach": {
			"kind": "function",
			"name": "module:uci.cursor#foreach",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"params": {
				"config": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "config",
					"description": "The configuration to iterate sections for, e.g. `\"system\"` to read the\n`/etc/config/system` file."
				},
				"type": {
					"type": [
						{
							"type": "string",
							"nullable": true
						}
					],
					"name": "type",
					"description": "Invoke the callback only for sections of the specified type."
				},
				"callback": {
					"type": [
						{
							"type": "module:uci.cursor.SectionCallback"
						}
					],
					"name": "callback",
					"description": "The callback to invoke for each section, will receive a section dictionary\nas sole argument."
				}
			},
			"subject": "Iterate configuration sections.",
			"description": "Iterate configuration sections.\n\nThe `foreach()` function iterates all sections of the given configuration,\noptionally filtered by type, and invokes the given callback function for\neach encountered section.\n\nWhen the optional \"type\" parameter is specified, the callback is only invoked\nfor sections of the given type, otherwise it is invoked for all sections.\n\nThe requested configuration is implicitly loaded into the cursor.\n\nReturns `true` if the callback was executed successfully at least once.\n\nReturns `false` if the callback was never invoked, e.g. when the\nconfiguration is empty or contains no sections of the given type.\n\nReturns `null` on error, e.g. when an invalid callback was passed or the\nrequested configuration not found."
		},
		"configs": {
			"kind": "function",
			"name": "module:uci.cursor#configs",
			"return": [
				{
					"type": "array",
					"itemtype": [
						{
							"type": "string"
						}
					],
					"nullable": true
				}
			],
			"subject": "Enumerate existing configurations.",
			"description": "Enumerate existing configurations.\n\nThe `configs()` function yields an array of configuration files present in\nthe cursors associated configuration directory, `/etc/config/` by default.\n\nReturns an array of configuration names on success.\n\nReturns `null` on error, e.g. due to filesystem errors."
		}
	},
	"uloop": {
		"error": {
			"kind": "function",
			"name": "module:uloop#error",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"description": "Retrieves the last error message.\n\nThis function retrieves the last error message generated by the uloop event loop.\nIf no error occurred, it returns `null`.",
			"subject": "Retrieves the last error message."
		},
		"init": {
			"kind": "function",
			"name": "module:uloop#init",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Initializes the uloop event loop.\n\nThis function initializes the uloop event loop, allowing subsequent\nusage of uloop functionalities. It takes no arguments.\n\nReturns `true` on success.\nReturns `null` if an error occurred during initialization.",
			"subject": "Initializes the uloop event loop."
		},
		"run": {
			"kind": "function",
			"name": "module:uloop#run",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Runs the uloop event loop.\n\nThis function starts running the uloop event loop, allowing it to handle\nscheduled events and callbacks. If a timeout value is provided and is\nnon-negative, the event loop will run for that amount of milliseconds\nbefore returning. If the timeout is omitted or negative, the event loop\nruns indefinitely until explicitly stopped.",
			"params": {
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout=-1]",
					"description": "Optional. The timeout value in milliseconds for running the event loop.\nDefaults to -1, indicating an indefinite run.",
					"default": "-1",
					"optional": true
				}
			},
			"subject": "Runs the uloop event loop."
		},
		"cancelling": {
			"kind": "function",
			"name": "module:uloop#cancelling",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Checks if the uloop event loop is currently shutting down.\n\nThis function checks whether the uloop event loop is currently in the process\nof shutting down.",
			"subject": "Checks if the uloop event loop is currently shutting down."
		},
		"running": {
			"kind": "function",
			"name": "module:uloop#running",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Checks if the uloop event loop is currently running.\n\nThis function checks whether the uloop event loop is currently started\nand running.",
			"subject": "Checks if the uloop event loop is currently running."
		},
		"end": {
			"kind": "function",
			"name": "module:uloop#end",
			"return": [
				{
					"type": "void"
				}
			],
			"description": "Halts the uloop event loop.\n\nThis function halts the uloop event loop, stopping its execution and\npreventing further processing of scheduled events and callbacks.\n\nExpired timeouts and already queued event callbacks are still run to\ncompletion.",
			"subject": "Halts the uloop event loop."
		},
		"done": {
			"kind": "function",
			"name": "module:uloop#done",
			"return": [
				{
					"type": "void"
				}
			],
			"description": "Stops the uloop event loop and cancels pending timeouts and events.\n\nThis function immediately stops the uloop event loop, cancels all pending\ntimeouts and events, unregisters all handles, and deallocates associated\nresources.",
			"subject": "Stops the uloop event loop and cancels pending timeouts and events."
		},
		"timer": {
			"kind": "function",
			"name": "module:uloop#timer",
			"return": [
				{
					"type": "module:uloop.timer",
					"nullable": true
				}
			],
			"description": "Creates a timer instance for scheduling callbacks.\n\nThis function creates a timer instance for scheduling callbacks to be\nexecuted after a specified timeout duration. It takes an optional timeout\nparameter, which defaults to -1, indicating that the timer is initially not\narmed and can be enabled later by invoking the `.set(timeout)` method on the\ninstance.\n\nA callback function must be provided to be executed when the timer expires.",
			"params": {
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout=-1]",
					"description": "Optional. The timeout duration in milliseconds. Defaults to -1, indicating\nthe timer is not initially armed.",
					"default": "-1",
					"optional": true
				},
				"callback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "callback",
					"description": "The callback function to be executed when the timer expires."
				}
			},
			"subject": "Creates a timer instance for scheduling callbacks."
		},
		"handle": {
			"kind": "function",
			"name": "module:uloop#handle",
			"return": [
				{
					"type": "module:uloop.handle",
					"nullable": true
				}
			],
			"description": "Creates a handle instance for monitoring file descriptor events.\n\nThis function creates a handle instance for monitoring events on a file\ndescriptor, file, or socket. It takes the file or socket handle, a callback\nfunction to be invoked when the specified IO events occur, and bitwise OR-ed\nflags of IO events (`ULOOP_READ`, `ULOOP_WRITE`) that the callback should be\ninvoked for.",
			"params": {
				"handle": {
					"type": [
						{
							"type": "number"
						},
						{
							"type": "module:fs.file"
						},
						{
							"type": "module:fs.proc"
						},
						{
							"type": "module:socket.socket"
						}
					],
					"name": "handle",
					"description": "The file handle (descriptor number, file or socket instance)."
				},
				"callback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "callback",
					"description": "The callback function to be invoked when the specified IO events occur."
				},
				"events": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "events",
					"description": "Bitwise OR-ed flags of IO events (`ULOOP_READ`, `ULOOP_WRITE`) that the\ncallback should be invoked for."
				}
			},
			"subject": "Creates a handle instance for monitoring file descriptor events."
		},
		"process": {
			"kind": "function",
			"name": "module:uloop#process",
			"return": [
				{
					"type": "module:uloop.process",
					"nullable": true
				}
			],
			"description": "Creates a process instance for executing external programs.\n\nThis function creates a process instance for executing external programs.\nIt takes the executable path string, an optional string array as the argument\nvector, an optional dictionary describing environment variables, and a\ncallback function to be invoked when the invoked process ends.",
			"params": {
				"executable": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "executable",
					"description": "The path to the executable program."
				},
				"args": {
					"type": [
						{
							"type": "array",
							"itemtype": [
								{
									"type": "string"
								}
							]
						}
					],
					"name": "[args]",
					"description": "Optional. An array of strings representing the arguments passed to the\nexecutable.",
					"optional": true
				},
				"env": {
					"type": [
						{
							"type": "object",
							"keytype": [
								{
									"type": "string"
								}
							],
							"itemtype": [
								{
									"type": "*"
								}
							]
						}
					],
					"name": "[env]",
					"description": "Optional. A dictionary describing environment variables for the process.",
					"optional": true
				},
				"callback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "callback",
					"description": "The callback function to be invoked when the invoked process ends."
				}
			},
			"subject": "Creates a process instance for executing external programs."
		},
		"task": {
			"kind": "function",
			"name": "module:uloop#task",
			"return": [
				{
					"type": "module:uloop.task",
					"nullable": true
				}
			],
			"description": "Creates a task instance for executing background tasks.\n\nThis function creates a task instance for executing background tasks.\nIt takes the task function to be invoked as a background process,\nan optional output callback function to be invoked when output is received\nfrom the task, and an optional input callback function to be invoked\nwhen input is required by the task.",
			"params": {
				"taskFunction": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "taskFunction",
					"description": "The task function to be invoked as a background process."
				},
				"outputCallback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "[outputCallback]",
					"description": "Optional. The output callback function to be invoked when output is received\nfrom the task. It is invoked with the output data as the argument.",
					"optional": true
				},
				"inputCallback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "[inputCallback]",
					"description": "Optional. The input callback function to be invoked when input is required\nby the task. It is invoked with a function to send input to the task\nas the argument.",
					"optional": true
				}
			},
			"subject": "Creates a task instance for executing background tasks."
		},
		"interval": {
			"kind": "function",
			"name": "module:uloop#interval",
			"return": [
				{
					"type": "module:uloop.interval",
					"nullable": true
				}
			],
			"description": "Creates an interval instance for scheduling repeated callbacks.\n\nThis function creates an interval instance for scheduling repeated callbacks\nto be executed at regular intervals. It takes an optional timeout parameter,\nwhich defaults to -1, indicating that the interval is initially not armed\nand can be armed later with the `.set(timeout)` method. A callback function\nmust be provided to be executed when the interval expires.",
			"params": {
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout=-1]",
					"description": "Optional. The interval duration in milliseconds. Defaults to -1, indicating\nthe interval is not initially armed.",
					"default": "-1",
					"optional": true
				},
				"callback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "callback",
					"description": "The callback function to be executed when the interval expires."
				}
			},
			"subject": "Creates an interval instance for scheduling repeated callbacks."
		},
		"signal": {
			"kind": "function",
			"name": "module:uloop#signal",
			"return": [
				{
					"type": "module:uloop.signal",
					"nullable": true
				}
			],
			"description": "Creates a signal instance for handling Unix signals.\n\nThis function creates a signal instance for handling Unix signals.\nIt takes the signal name string (with or without \"SIG\" prefix) or signal\nnumber, and a callback function to be invoked when the specified Unix signal\nis caught.",
			"params": {
				"signal": {
					"type": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					],
					"name": "signal",
					"description": "The signal name string (with or without \"SIG\" prefix) or signal number."
				},
				"callback": {
					"type": [
						{
							"type": "function"
						}
					],
					"name": "callback",
					"description": "The callback function to be invoked when the specified Unix signal is caught."
				}
			},
			"subject": "Creates a signal instance for handling Unix signals."
		}
	},
	"uloop.timer": {
		"set": {
			"kind": "function",
			"name": "module:uloop.timer#set",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Rearms the uloop timer with the specified timeout.\n\nThis method rearms the uloop timer with the specified timeout value,\nallowing it to trigger after the specified amount of time. If no timeout\nvalue is provided or if the provided value is negative, the timer remains\ndisabled until rearmed with a positive timeout value.",
			"params": {
				"timeout": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[timeout=-1]",
					"description": "Optional. The timeout value in milliseconds until the timer expires.\nDefaults to -1, which disables the timer until rearmed with a positive timeout.",
					"default": "-1",
					"optional": true
				}
			},
			"subject": "Rearms the uloop timer with the specified timeout."
		},
		"remaining": {
			"kind": "function",
			"name": "module:uloop.timer#remaining",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the number of milliseconds until the uloop timer expires.\n\nThis method returns the remaining time until the uloop timer expires. If\nthe timer is not armed (i.e., disabled), it returns -1.",
			"subject": "Returns the number of milliseconds until the uloop timer expires."
		},
		"cancel": {
			"kind": "function",
			"name": "module:uloop.timer#cancel",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Cancels the uloop timer, disarming it and removing it from the event loop.\n\nThis method destroys the uloop timer and releases its associated resources.",
			"subject": "Cancels the uloop timer, disarming it and removing it from the event loop."
		}
	},
	"uloop.handle": {
		"fileno": {
			"kind": "function",
			"name": "module:uloop.handle#fileno",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the file descriptor number.\n\nThis method returns the file descriptor number associated with the underlying\nhandle, which might refer to a socket or file instance.",
			"subject": "Returns the file descriptor number."
		},
		"handle": {
			"kind": "function",
			"name": "module:uloop.handle#handle",
			"return": [
				{
					"type": "module:fs.file"
				},
				{
					"type": "module:fs.proc"
				},
				{
					"type": "module:socket.socket"
				}
			],
			"description": "Returns the underlying file or socket instance.\n\nThis method returns the underlying file or socket instance associated with\nthe uloop handle.",
			"subject": "Returns the underlying file or socket instance."
		},
		"delete": {
			"kind": "function",
			"name": "module:uloop.handle#delete",
			"return": [
				{
					"type": "void"
				}
			],
			"description": "Unregisters the uloop handle.\n\nThis method unregisters the uloop handle from the uloop event loop and frees\nany associated resources. After calling this method, the handle instance\nshould no longer be used.",
			"subject": "Unregisters the uloop handle."
		}
	},
	"uloop.process": {
		"pid": {
			"kind": "function",
			"name": "module:uloop.process#pid",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the process ID.\n\nThis method returns the process ID (PID) of the operating system process\nlaunched by {@link module:uloop#process|process().",
			"subject": "Returns the process ID."
		},
		"delete": {
			"kind": "function",
			"name": "module:uloop.process#delete",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Unregisters the process from uloop.\n\nThis method unregisters the process from the uloop event loop and releases\nany associated resources. However, note that the operating system process\nitself is not terminated by this method.",
			"subject": "Unregisters the process from uloop."
		}
	},
	"uloop.pipe": {
		"send": {
			"kind": "function",
			"name": "module:uloop.pipe#send",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Sends a serialized message to the task handle.\n\nThis method serializes the provided message and sends it over the task\ncommunication pipe. In the main thread, the message is deserialized and\npassed as an argument to the output callback function registered with the\ntask handle.",
			"params": {
				"msg": {
					"type": [
						{
							"type": "*"
						}
					],
					"name": "msg",
					"description": "The message to be serialized and sent over the pipe. It can be of arbitrary type."
				}
			},
			"subject": "Sends a serialized message to the task handle."
		},
		"receive": {
			"kind": "function",
			"name": "module:uloop.pipe#receive",
			"return": [
				{
					"type": "*",
					"nullable": true
				}
			],
			"description": "Reads input from the task handle.\n\nThis method reads input from the task communication pipe. The input callback\nfunction registered with the task handle is invoked to return the input data,\nwhich is then serialized, sent over the pipe, and deserialized by the receive\nmethod.",
			"subject": "Reads input from the task handle."
		},
		"sending": {
			"kind": "function",
			"name": "module:uloop.pipe#sending",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Checks if the task handle provides input.\n\nThis method checks if the task handle has an input callback  registered.\nIt returns a boolean value indicating whether an input callback is present.",
			"subject": "Checks if the task handle provides input."
		},
		"receiving": {
			"kind": "function",
			"name": "module:uloop.pipe#receiving",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Checks if the task handle reads output.\n\nThis method checks if the task handle has an output callback registered.\nIt returns a boolean value indicating whether an output callback is present.",
			"subject": "Checks if the task handle reads output."
		}
	},
	"uloop.task": {
		"pid": {
			"kind": "function",
			"name": "module:uloop.task#pid",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the process ID.\n\nThis method returns the process ID (PID) of the underlying forked process\nlaunched by {@link module:uloop#task|task().",
			"subject": "Returns the process ID."
		},
		"kill": {
			"kind": "function",
			"name": "module:uloop.task#kill",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Terminates the task process.\n\nThis method terminates the task process. It sends a termination signal to\nthe task process, causing it to exit. Returns `true` on success, indicating\nthat the task process was successfully terminated. Returns `null` on error,\nsuch as when the task process has already terminated.",
			"subject": "Terminates the task process."
		},
		"finished": {
			"kind": "function",
			"name": "module:uloop.task#finished",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Checks if the task ran to completion.\n\nThis method checks if the task function has already run to completion.\nIt returns a boolean value indicating whether the task function has finished\nexecuting.",
			"subject": "Checks if the task ran to completion."
		}
	},
	"uloop.interval": {
		"set": {
			"kind": "function",
			"name": "module:uloop.interval#set",
			"return": [
				{
					"type": "boolean",
					"nullable": true
				}
			],
			"description": "Rearms the uloop interval timer with the specified interval.\n\nThis method rearms the interval timer with the specified interval value,\nallowing it to trigger repeatedly after the specified amount of time. If no\ninterval value is provided or if the provided value is negative, the interval\nremains disabled until rearmed with a positive interval value.",
			"params": {
				"interval": {
					"type": [
						{
							"type": "number"
						}
					],
					"name": "[interval=-1]",
					"description": "Optional. The interval value in milliseconds specifying when the interval\ntriggers again. Defaults to -1, which disables the interval until rearmed\nwith a positive interval value.",
					"default": "-1",
					"optional": true
				}
			},
			"subject": "Rearms the uloop interval timer with the specified interval."
		},
		"remaining": {
			"kind": "function",
			"name": "module:uloop.interval#remaining",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the milliseconds until the next expiration.\n\nThis method returns the remaining time until the uloop interval expires\nand triggers again. If the interval is not armed (i.e., disabled),\nit returns -1.",
			"subject": "Returns the milliseconds until the next expiration."
		},
		"expirations": {
			"kind": "function",
			"name": "module:uloop.interval#expirations",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns number of times the interval timer fired.\n\nThis method returns the number of times the uloop interval timer has expired\n(fired) since it was instantiated.",
			"subject": "Returns number of times the interval timer fired."
		},
		"cancel": {
			"kind": "function",
			"name": "module:uloop.interval#cancel",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Cancels the uloop interval.\n\nThis method cancels the uloop interval, disarming it and removing it from the\nevent loop. Associated resources are released.",
			"subject": "Cancels the uloop interval."
		}
	},
	"uloop.signal": {
		"signo": {
			"kind": "function",
			"name": "module:uloop.signal#signo",
			"return": [
				{
					"type": "number"
				}
			],
			"description": "Returns the associated signal number.\n\nThis method returns the signal number that this uloop signal handler is\nconfigured to respond to.",
			"subject": "Returns the associated signal number."
		},
		"delete": {
			"kind": "function",
			"name": "module:uloop.signal#delete",
			"return": [
				{
					"type": "boolean"
				}
			],
			"description": "Uninstalls the signal handler.\n\nThis method uninstalls the signal handler, restoring the previous or default\nhandler for the signal, and releasing any associated resources.",
			"subject": "Uninstalls the signal handler."
		}
	},
	"zlib": {
		"deflate": {
			"kind": "function",
			"name": "module:zlib#deflate",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"str_or_resource": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str_or_resource",
					"description": "The string or resource object to be parsed as JSON."
				},
				"gzip": {
					"type": [
						{
							"type": "boolean",
							"nullable": true
						}
					],
					"name": "[gzip=false]",
					"description": "Add a gzip header if true (creates a gzip-compliant output, otherwise defaults to Zlib)",
					"default": "false",
					"optional": true
				},
				"level": {
					"type": [
						{
							"type": "number",
							"nullable": true
						}
					],
					"name": "[level=Z_DEFAULT_COMPRESSION]",
					"description": "The compression level (0-9).",
					"default": "Z_DEFAULT_COMPRESSION",
					"optional": true
				}
			},
			"subject": "Compresses data in Zlib or gzip format.",
			"description": "Compresses data in Zlib or gzip format.\n\nIf the input argument is a plain string, it is directly compressed.\n\nIf an array, object or resource value is given, this function will attempt to\ninvoke a `read()` method on it to read chunks of input text to incrementally\ncompress. Reading will stop if the object's `read()` method returns\neither `null` or an empty string.\n\nThrows an exception on errors.\n\nReturns the compressed data."
		},
		"inflate": {
			"kind": "function",
			"name": "module:zlib#inflate",
			"return": [
				{
					"type": "string",
					"nullable": true
				}
			],
			"params": {
				"str_or_resource": {
					"type": [
						{
							"type": "string"
						}
					],
					"name": "str_or_resource",
					"description": "The string or resource object to be parsed as JSON."
				}
			},
			"subject": "Decompresses data in Zlib or gzip format.",
			"description": "Decompresses data in Zlib or gzip format.\n\nIf the input argument is a plain string, it is directly decompressed.\n\nIf an array, object or resource value is given, this function will attempt to\ninvoke a `read()` method on it to read chunks of input text to incrementally\ndecompress. Reading will stop if the object's `read()` method returns\neither `null` or an empty string.\n\nThrows an exception on errors.\n\nReturns the decompressed data."
		}
	}
}
