<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link type="text/css" rel="stylesheet" href="ucode.css"><title>Module: struct</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol><symbol id="toc-icon" viewBox="0 0 460 460"><path d="M40 70a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM40 190a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM40 310a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM430 80H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60zM430 200H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60zM430 320H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60z"/></symbol></defs></svg></head><body data-theme="light"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">ucode Documentation</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="iRteTbw_GIm_no2QxC7Ui"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-01-usage.html">Usage</a></div><div class="sidebar-section-children"><a href="tutorial-02-syntax.html">Syntax</a></div><div class="sidebar-section-children"><a href="tutorial-03-memory.html">Memory Management</a></div><div class="sidebar-section-children"><a href="tutorial-04-arrays.html">Working with Arrays</a></div><div class="sidebar-section-children"><a href="tutorial-05-dictionaries.html">Working with Dictionaries</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="RkYR_HGnjdFY7GbgDn8vo"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core.html">core</a></div><div class="sidebar-section-children"><a href="module-debug.html">debug</a></div><div class="sidebar-section-children"><a href="module-digest.html">digest</a></div><div class="sidebar-section-children"><a href="module-fs.html">fs</a></div><div class="sidebar-section-children"><a href="module-log.html">log</a></div><div class="sidebar-section-children"><a href="module-math.html">math</a></div><div class="sidebar-section-children"><a href="module-socket.html">socket</a></div><div class="sidebar-section-children"><a href="module-struct.html">struct</a></div><div class="sidebar-section-children"><a href="module-uci.html">uci</a></div><div class="sidebar-section-children"><a href="module-uloop.html">uloop</a></div><div class="sidebar-section-children"><a href="module-zlib.html">zlib</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="github-home navbar-item"><a id="" href="https://github.com/jow-/ucode" target="">GitHub Project Page</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div><div class="navbar-right-item toc-item"><button class="icon-button toc" aria-label="open-table-of-contents"><svg><use xlink:href="#toc-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section><header></header><article><div class="container-overview"><div class="description"><h1 id="handle-packed-binary-data">Handle Packed Binary Data</h1><p>The <code>struct</code> module provides routines for interpreting byte strings as packed binary data.</p><p>Functions can be individually imported and directly accessed using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#named_import">named import</a> syntax:</p><pre class="prettyprint source"><code>import { pack, unpack } from 'struct';

let buffer = pack('bhl', -13, 1234, 444555666);
let values = unpack('bhl', buffer);
</code></pre><p>Alternatively, the module namespace can be imported using a wildcard import statement:</p><pre class="prettyprint source"><code>import * as struct from 'struct';

let buffer = struct.pack('bhl', -13, 1234, 444555666);
let values = struct.unpack('bhl', buffer);
</code></pre><p>Additionally, the struct module namespace may also be imported by invoking the <code>ucode</code> interpreter with the <code>-lstruct</code> switch.</p><h2 id="format-strings">Format Strings</h2><p>Format strings describe the data layout when packing and unpacking data. They are built up from format-characters, which specify the type of data being packed/unpacked. In addition, special characters control the byte order, size and alignment.</p><p>Each format string consists of an optional prefix character which describes the overall properties of the data and one or more format characters which describe the actual data values and padding.</p><h3 id="byte-order%2C-size%2C-and-alignment">Byte Order, Size, and Alignment</h3><p>By default, C types are represented in the machine's native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler).</p><p>This behavior is chosen so that the bytes of a packed struct correspond exactly to the memory layout of the corresponding C struct.</p><p>Whether to use native byte ordering and padding or standard formats depends on the application.</p><p>Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table:</p><table><thead><tr><th>Character</th><th>Byte order</th><th>Size</th><th>Alignment</th></tr></thead><tbody><tr><td><code>@</code></td><td>native</td><td>native</td><td>native</td></tr><tr><td><code>=</code></td><td>native</td><td>standard</td><td>none</td></tr><tr><td><code>&lt;</code></td><td>little-endian</td><td>standard</td><td>none</td></tr><tr><td><code>&gt;</code></td><td>big-endian</td><td>standard</td><td>none</td></tr><tr><td><code>!</code></td><td>network (= big-endian)</td><td>standard</td><td>none</td></tr></tbody></table><p>If the first character is not one of these, <code>'@'</code> is assumed.</p><p>Native byte order is big-endian or little-endian, depending on the host system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-endian; IBM z and many legacy architectures are big-endian.</p><p>Native size and alignment are determined using the C compiler's <code>sizeof</code> expression. This is always combined with native byte order.</p><p>Standard size depends only on the format character; see the table in the <code>format-characters</code> section.</p><p>Note the difference between <code>'@'</code> and <code>'='</code>: both use native byte order, but the size and alignment of the latter is standardized.</p><p>The form <code>'!'</code> represents the network byte order which is always big-endian as defined in <code>IETF RFC 1700</code>.</p><p>There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of <code>'&lt;'</code> or <code>'&gt;'</code>.</p><p>Notes:</p><p>(1) Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct.</p><p>(2) No padding is added when using non-native size and alignment, e.g. with '&lt;', '&gt;', '=', and '!'.</p><p>(3) To align the end of a structure to the alignment requirement of a particular type, end the format with the code for that type with a repeat count of zero.</p><h3 id="format-characters">Format Characters</h3><p>Format characters have the following meaning; the conversion between C and ucode values should be obvious given their types. The 'Standard size' column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of <code>'&lt;'</code>, <code>'&gt;'</code>, <code>'!'</code> or <code>'='</code>. When using native size, the size of the packed value is platform dependent.</p><table><thead><tr><th>Format</th><th>C Type</th><th>Ucode type</th><th>Standard size</th><th>Notes</th></tr></thead><tbody><tr><td><code>x</code></td><td><em>pad byte</em></td><td><em>no value</em></td><td></td><td>(7)</td></tr><tr><td><code>c</code></td><td><code>char</code></td><td>string</td><td>1</td><td></td></tr><tr><td><code>b</code></td><td><code>signed char</code></td><td>int</td><td>1</td><td>(1), (2)</td></tr><tr><td><code>B</code></td><td><code>unsigned char</code></td><td>int</td><td>1</td><td>(2)</td></tr><tr><td><code>?</code></td><td><code>_Bool</code></td><td>bool</td><td>1</td><td>(1)</td></tr><tr><td><code>h</code></td><td><code>short</code></td><td>int</td><td>2</td><td>(2)</td></tr><tr><td><code>H</code></td><td><code>unsigned short</code></td><td>int</td><td>2</td><td>(2)</td></tr><tr><td><code>i</code></td><td><code>int</code></td><td>int</td><td>4</td><td>(2)</td></tr><tr><td><code>I</code></td><td><code>unsigned int</code></td><td>int</td><td>4</td><td>(2)</td></tr><tr><td><code>l</code></td><td><code>long</code></td><td>int</td><td>4</td><td>(2)</td></tr><tr><td><code>L</code></td><td><code>unsigned long</code></td><td>int</td><td>4</td><td>(2)</td></tr><tr><td><code>q</code></td><td><code>long long</code></td><td>int</td><td>8</td><td>(2)</td></tr><tr><td><code>Q</code></td><td><code>unsigned long long</code></td><td>int</td><td>8</td><td>(2)</td></tr><tr><td><code>n</code></td><td><code>ssize_t</code></td><td>int</td><td></td><td>(3)</td></tr><tr><td><code>N</code></td><td><code>size_t</code></td><td>int</td><td></td><td>(3)</td></tr><tr><td><code>e</code></td><td>(6)</td><td>double</td><td>2</td><td>(4)</td></tr><tr><td><code>f</code></td><td><code>float</code></td><td>double</td><td>4</td><td>(4)</td></tr><tr><td><code>d</code></td><td><code>double</code></td><td>double</td><td>8</td><td>(4)</td></tr><tr><td><code>s</code></td><td><code>char[]</code></td><td>double</td><td></td><td>(9)</td></tr><tr><td><code>p</code></td><td><code>char[]</code></td><td>double</td><td></td><td>(8)</td></tr><tr><td><code>P</code></td><td><code>void *</code></td><td>int</td><td></td><td>(5)</td></tr><tr><td><code>*</code></td><td><code>char[]</code></td><td>string</td><td></td><td>(10)</td></tr></tbody></table><p>Notes:</p><ul><li><p>(1) The <code>'?'</code> conversion code corresponds to the <code>_Bool</code> type defined by C99. If this type is not available, it is simulated using a <code>char</code>. In standard mode, it is always represented by one byte.</p></li><li><p>(2) When attempting to pack a non-integer using any of the integer conversion codes, this module attempts to convert the given value into an integer. If the value is not convertible, a type error exception is thrown.</p></li><li><p>(3) The <code>'n'</code> and <code>'N'</code> conversion codes are only available for the native size (selected as the default or with the <code>'@'</code> byte order character). For the standard size, you can use whichever of the other integer formats fits your application.</p></li><li><p>(4) For the <code>'f'</code>, <code>'d'</code> and <code>'e'</code> conversion codes, the packed representation uses the IEEE 754 binary32, binary64 or binary16 format (for <code>'f'</code>, <code>'d'</code> or <code>'e'</code> respectively), regardless of the floating-point format used by the platform.</p></li><li><p>(5) The <code>'P'</code> format character is only available for the native byte ordering (selected as the default or with the <code>'@'</code> byte order character). The byte order character <code>'='</code> chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the <code>'P'</code> format is not available.</p></li><li><p>(6) The IEEE 754 binary16 &quot;half precision&quot; type was introduced in the 2008 revision of the <code>IEEE 754</code> standard. It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately <code>6.1e-05</code> and <code>6.5e+04</code> at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the <code>half-precision floating-point format</code> for more information.</p></li><li><p>(7) When packing, <code>'x'</code> inserts one NUL byte.</p></li><li><p>(8) The <code>'p'</code> format character encodes a &quot;Pascal string&quot;, meaning a short variable-length string stored in a <em>fixed number of bytes</em>, given by the count. The first byte stored is the length of the string, or 255, whichever is smaller. The bytes of the string follow. If the string passed in to <code>pack()</code> is too long (longer than the count minus 1), only the leading <code>count-1</code> bytes of the string are stored. If the string is shorter than <code>count-1</code>, it is padded with null bytes so that exactly count bytes in all are used. Note that for <code>unpack()</code>, the <code>'p'</code> format character consumes <code>count</code> bytes, but that the string returned can never contain more than 255 bytes.</p></li><li><p>(9) For the <code>'s'</code> format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, <code>'10s'</code> means a single 10-byte string mapping to or from a single ucode byte string, while <code>'10c'</code> means 10 separate one byte character elements (e.g., <code>cccccccccc</code>) mapping to or from ten different ucode byte strings. If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, <code>'0s'</code> means a single, empty string (while <code>'0c'</code> means 0 characters).</p></li><li><p>(10) The <code>*</code> format character serves as wildcard. For <code>pack()</code> it will append the corresponding byte argument string as-is, not applying any padding or zero filling. When a repeat count is given, that many bytes of the input byte string argument will be appended at most on <code>pack()</code>, effectively truncating longer input strings. For <code>unpack()</code>, the wildcard format will yield a byte string containing the entire remaining input data bytes, or - when a repeat count is given - that many bytes of input data at most.</p></li></ul><p>A format character may be preceded by an integral repeat count. For example, the format string <code>'4h'</code> means exactly the same as <code>'hhhh'</code>.</p><p>Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.</p><p>When packing a value <code>x</code> using one of the integer formats (<code>'b'</code>, <code>'B'</code>, <code>'h'</code>, <code>'H'</code>, <code>'i'</code>, <code>'I'</code>, <code>'l'</code>, <code>'L'</code>, <code>'q'</code>, <code>'Q'</code>), if <code>x</code> is outside the valid range for that format, a type error exception is raised.</p><p>For the <code>'?'</code> format character, the return value is either <code>true</code> or <code>false</code>. When packing, the truish result value of the argument is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be <code>true</code> when unpacking.</p><h2 id="examples">Examples</h2><p>Note: Native byte order examples (designated by the <code>'@'</code> format prefix or lack of any prefix character) may not match what the reader's machine produces as that depends on the platform and compiler.</p><p>Pack and unpack integers of three different sizes, using big endian ordering:</p><pre class="prettyprint source"><code>import { pack, unpack } from 'struct';

pack(&quot;>bhl&quot;, 1, 2, 3);  // &quot;\x01\x00\x02\x00\x00\x00\x03&quot;
unpack(&quot;>bhl&quot;, &quot;\x01\x00\x02\x00\x00\x00\x03&quot;);  // [ 1, 2, 3 ]
</code></pre><p>Attempt to pack an integer which is too large for the defined field:</p><pre class="prettyprint source lang-bash"><code>$ ucode -lstruct -p 'struct.pack(&quot;>h&quot;, 99999)'
Type error: Format 'h' requires numeric argument between -32768 and 32767
In [-p argument], line 1, byte 24:

 `struct.pack(&quot;>h&quot;, 99999)`
  Near here -------------^
</code></pre><p>Demonstrate the difference between <code>'s'</code> and <code>'c'</code> format characters:</p><pre class="prettyprint source"><code>import { pack } from 'struct';

pack(&quot;@ccc&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);  // &quot;123&quot;
pack(&quot;@3s&quot;, &quot;123&quot;);           // &quot;123&quot;
</code></pre><p>The ordering of format characters may have an impact on size in native mode since padding is implicit. In standard mode, the user is responsible for inserting any desired padding.</p><p>Note in the first <code>pack()</code> call below that three NUL bytes were added after the packed <code>'#'</code> to align the following integer on a four-byte boundary. In this example, the output was produced on a little endian machine:</p><pre class="prettyprint source"><code>import { pack } from 'struct';

pack(&quot;@ci&quot;, &quot;#&quot;, 0x12131415);  // &quot;#\x00\x00\x00\x15\x14\x13\x12&quot;
pack(&quot;@ic&quot;, 0x12131415, &quot;#&quot;);  // &quot;\x15\x14\x13\x12#&quot;
</code></pre><p>The following format <code>'ih0i'</code> results in two pad bytes being added at the end, assuming the platform's ints are aligned on 4-byte boundaries:</p><pre class="prettyprint source"><code>import { pack } from 'struct';

pack(&quot;ih0i&quot;, 0x01010101, 0x0202);  // &quot;\x01\x01\x01\x01\x02\x02\x00\x00&quot;
</code></pre><p>Use the wildcard format to extract the remainder of the input data:</p><pre class="prettyprint source"><code>import { unpack } from 'struct';

unpack(&quot;ccc*&quot;, &quot;foobarbaz&quot;);   // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot;, &quot;barbaz&quot; ]
unpack(&quot;ccc3*&quot;, &quot;foobarbaz&quot;);  // [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot;, &quot;bar&quot; ]
</code></pre><p>Use the wildcard format to pack binary stings as-is into the result data:</p><pre class="prettyprint source"><code>import { pack } from 'struct';

pack(&quot;h*h&quot;, 0x0101, &quot;\x02\x00\x03&quot;, 0x0404);  // &quot;\x01\x01\x02\x00\x03\x04\x04&quot;
pack(&quot;c3*c&quot;, &quot;a&quot;, &quot;foobar&quot;, &quot;c&quot;);  // &quot;afooc&quot;
</code></pre></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="lib_struct.c.html">lib/struct.c</a>, <a href="lib_struct.c.html#line63">line 63</a></li></ul></dd></div></dl></div><h2 id="classes" class="subsection-title has-anchor">Classes</h2><h3 id="module:struct.buffer" class="name"><span class="ancestors">struct.</span><a href="module-struct.buffer.html">buffer</a></h3><p>Represents a struct buffer instance created by <code>buffer()</code>.</p><h3 id="module:struct.instance" class="name"><span class="ancestors">struct.</span><a href="module-struct.instance.html">instance</a></h3><p>Represents a struct instance created by <code>new()</code>.</p><h2 id="methods" class="subsection-title has-anchor">Methods</h2><h3 class="name has-anchor" id="buffer"><span class="type-signature"></span>buffer<span class="signature">(initialData<span class="signature-attributes">opt</span>)</span> <span class="type-signature">&rarr; {<a href="module-struct.buffer.html">buffer</a>}</span></h3><div class="description"><p>Creates a new struct buffer instance.</p><p>The <code>buffer()</code> function creates a new struct buffer object that can be used for incremental packing and unpacking of binary data. If an initial data string is provided, the buffer is initialized with this content.</p><p>Note that even when initial data is provided, the buffer position is always set to zero. This design assumes that the primary intent when initializing a buffer with data is to read (unpack) from the beginning. If you want to append data to a pre-initialized buffer, you need to explicitly move the position to the end, either by calling <code>end()</code> or by setting the position manually with <code>pos()</code>.</p><p>Returns a new struct buffer instance.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th class="type">Type</th><th class="description last">Description</th></tr></thead><tbody><tr><td class="name"><code>initialData</code></td><td class="type"><span class="type-signature">string</span></td><td class="description last"><span class="inline-attributes">(optional)</span><p>Optional initial data to populate the buffer with.</p></td></tr></tbody></table></div><div class="method-member-container mt-20"><strong>Returns:</strong> <span class="type-signature"><a href="module-struct.buffer.html">buffer</a></span></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>// Create an empty buffer
const emptyBuf = struct.buffer();

// Create a buffer with initial data
const dataBuf = struct.buffer("\x01\x02\x03\x04");

// Read from the beginning of the initialized buffer
const value = dataBuf.get('I');

// Append data to the initialized buffer
dataBuf.end().put('I', 5678);

// Alternative chained syntax for initializing and appending
const buf = struct.buffer("\x01\x02\x03\x04").end().put('I', 5678);</code></pre></div></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="lib_struct.c.html">lib/struct.c</a>, <a href="lib_struct.c.html#line3030">line 3030</a></li></ul></dd></div></dl><h3 class="name has-anchor" id="new"><span class="type-signature"></span>new<span class="signature">(format)</span> <span class="type-signature">&rarr; {<a href="module-struct.instance.html">instance</a>}</span></h3><div class="description"><p>Precompile format string.</p><p>The <code>new()</code> function precompiles the given format string argument and returns a <code>struct</code> object instance useful for packing and unpacking multiple items without having to recompute the internal format each time.</p><p>Returns an precompiled struct format instance.</p><p>Raises a runtime exception if the format string is invalid.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th class="type">Type</th><th class="description last">Description</th></tr></thead><tbody><tr><td class="name"><code>format</code></td><td class="type"><span class="type-signature">string</span></td><td class="description last"><p>The format string.</p></td></tr></tbody></table></div><div class="method-member-container mt-20"><strong>Returns:</strong> <span class="type-signature"><a href="module-struct.instance.html">instance</a></span></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>// Create a format of three consecutive unsigned int values in network byte order.
const fmt = struct.new('!III');
const buf = fmt.pack(1, 2, 3);  // "\x00\x00\x00\x01…"
print(fmt.unpack(buf), "\n");   // [ 1, 2, 3 ]</code></pre></div></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="lib_struct.c.html">lib/struct.c</a>, <a href="lib_struct.c.html#line2872">line 2872</a></li></ul></dd></div></dl><h3 class="name has-anchor" id="pack"><span class="type-signature"></span>pack<span class="signature">(format, &hellip;values)</span> <span class="type-signature">&rarr; {string}</span></h3><div class="description"><p>Pack given values according to specified format.</p><p>The <code>pack()</code> function creates a byte string containing the argument values packed according to the given format string.</p><p>Returns the packed string.</p><p>Raises a runtime exception if a given argument value does not match the required type of the corresponding format string directive or if and invalid format string is provided.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th class="type">Type</th><th class="description last">Description</th></tr></thead><tbody><tr><td class="name"><code>format</code></td><td class="type"><span class="type-signature">string</span></td><td class="description last"><p>The format string.</p></td></tr><tr><td class="name"><code>values</code></td><td class="type"><span class="type-signature">*</span></td><td class="description last"><span class="inline-attributes">(repeatable)</span><p>Variable number of values to pack.</p></td></tr></tbody></table></div><div class="method-member-container mt-20"><strong>Returns:</strong> <span class="type-signature">string</span></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>// Pack the values 1, 2, 3 as three consecutive unsigned int values
// in network byte order.
const data = pack('!III', 1, 2, 3);</code></pre></div></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="lib_struct.c.html">lib/struct.c</a>, <a href="lib_struct.c.html#line2729">line 2729</a></li></ul></dd></div></dl><h3 class="name has-anchor" id="unpack"><span class="type-signature"></span>unpack<span class="signature">(format, input, offset<span class="signature-attributes">opt</span>)</span> <span class="type-signature">&rarr; {array}</span></h3><div class="description"><p>Unpack given byte string according to specified format.</p><p>The <code>unpack()</code> function interpretes a byte string according to the given format string and returns the resulting values. If the optional offset argument is given, unpacking starts from this byte position within the input. If not specified, the start offset defaults to <code>0</code>, the start of the given input string.</p><p>Returns an array of unpacked values.</p><p>Raises a runtime exception if the format string is invalid or if an invalid input string or offset value is given.</p></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Parameters:</strong><table class="params"><thead><tr><th>Name</th><th class="type">Type</th><th class="description last">Description</th></tr></thead><tbody><tr><td class="name"><code>format</code></td><td class="type"><span class="type-signature">string</span></td><td class="description last"><p>The format string.</p></td></tr><tr><td class="name"><code>input</code></td><td class="type"><span class="type-signature">string</span></td><td class="description last"><p>The input string to unpack.</p></td></tr><tr><td class="name"><code>offset</code></td><td class="type"><span class="type-signature">number</span></td><td class="description last"><span class="inline-attributes">(optional, default: <code>0</code>)</span><p>The offset within the input string to start unpacking from.</p></td></tr></tbody></table></div><div class="method-member-container mt-20"><strong>Returns:</strong> <span class="type-signature">array</span></div><div class="method-member-container flex flex-col w-100 overflow-auto mt-20"><strong>Example</strong><div class="rel"><pre class="prettyprint"><code>// Unpack three consecutive unsigned int values in network byte order.
const numbers =
  unpack('!III', '\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03');
print(numbers, "\n"); // [ 1, 2, 3 ]</code></pre></div></div><dl class="details"><div class="details-item-container"><dt class="tag-source bold">Source</dt><dd class="tag-source"><ul><li><a href="lib_struct.c.html">lib/struct.c</a>, <a href="lib_struct.c.html#line2785">line 2785</a></li></ul></dd></div></dl></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button> <button class="icon-button" id="mobile-toc" data-isopen="false" aria-label="toc"><svg><use xlink:href="#toc-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">ucode Documentation</a><div class="mobile-nav-links"><div class="github-home navbar-item"><a id="" href="https://github.com/jow-/ucode" target="">GitHub Project Page</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="iRteTbw_GIm_no2QxC7Ui"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-01-usage.html">Usage</a></div><div class="sidebar-section-children"><a href="tutorial-02-syntax.html">Syntax</a></div><div class="sidebar-section-children"><a href="tutorial-03-memory.html">Memory Management</a></div><div class="sidebar-section-children"><a href="tutorial-04-arrays.html">Working with Arrays</a></div><div class="sidebar-section-children"><a href="tutorial-05-dictionaries.html">Working with Dictionaries</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="RkYR_HGnjdFY7GbgDn8vo"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core.html">core</a></div><div class="sidebar-section-children"><a href="module-debug.html">debug</a></div><div class="sidebar-section-children"><a href="module-digest.html">digest</a></div><div class="sidebar-section-children"><a href="module-fs.html">fs</a></div><div class="sidebar-section-children"><a href="module-log.html">log</a></div><div class="sidebar-section-children"><a href="module-math.html">math</a></div><div class="sidebar-section-children"><a href="module-socket.html">socket</a></div><div class="sidebar-section-children"><a href="module-struct.html">struct</a></div><div class="sidebar-section-children"><a href="module-uci.html">uci</a></div><div class="sidebar-section-children"><a href="module-uloop.html">uloop</a></div><div class="sidebar-section-children"><a href="module-zlib.html">zlib</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div><div class="navbar-right-item toc-item"><button class="icon-button toc" aria-label="open-table-of-contents"><svg><use xlink:href="#toc-icon"></use></svg></button></div></div></div></div><div id="mobile-tocbar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><span class="sidebar-title">Table of Contents</span><div class="toc-contents"></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#mobile-tocbar > .mobile-sidebar-wrapper > .toc-contents",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:(...e)=>{hideMobileMenu(),bringLinkToView(...e)},includeHtml:!0})</script></body></html>