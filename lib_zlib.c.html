<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link type="text/css" rel="stylesheet" href="ucode.css"><title>Source: lib/zlib.c</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol><symbol id="toc-icon" viewBox="0 0 460 460"><path d="M40 70a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM40 190a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM40 310a40 40 0 1 0 0 80 40 40 0 0 0 0-80zM430 80H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60zM430 200H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60zM430 320H145a30 30 0 0 0 0 60h285a30 30 0 0 0 0-60z"/></symbol></defs></svg></head><body data-theme="light"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">ucode Documentation</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="Mn2ZtWaSCf8lxqBM30jM0"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-01-usage.html">Usage</a></div><div class="sidebar-section-children"><a href="tutorial-02-syntax.html">Syntax</a></div><div class="sidebar-section-children"><a href="tutorial-03-memory.html">Memory Management</a></div><div class="sidebar-section-children"><a href="tutorial-04-arrays.html">Working with Arrays</a></div><div class="sidebar-section-children"><a href="tutorial-05-dictionaries.html">Working with Dictionaries</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="P3uD-u9aSgJIACEZlfa4D"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core.html">core</a></div><div class="sidebar-section-children"><a href="module-debug.html">debug</a></div><div class="sidebar-section-children"><a href="module-digest.html">digest</a></div><div class="sidebar-section-children"><a href="module-fs.html">fs</a></div><div class="sidebar-section-children"><a href="module-log.html">log</a></div><div class="sidebar-section-children"><a href="module-math.html">math</a></div><div class="sidebar-section-children"><a href="module-resolv.html">resolv</a></div><div class="sidebar-section-children"><a href="module-socket.html">socket</a></div><div class="sidebar-section-children"><a href="module-struct.html">struct</a></div><div class="sidebar-section-children"><a href="module-uci.html">uci</a></div><div class="sidebar-section-children"><a href="module-uloop.html">uloop</a></div><div class="sidebar-section-children"><a href="module-zlib.html">zlib</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"><div class="github-home navbar-item"><a id="" href="https://github.com/jow-/ucode" target="">GitHub Project Page</a></div></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div><div class="navbar-right-item toc-item"><button class="icon-button toc" aria-label="open-table-of-contents"><svg><use xlink:href="#toc-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">lib_zlib.c</h1></header><article><pre class="prettyprint source lang-js"><code>/*
 * Copyright (C) 2024 Thibaut VARÈNE &lt;hacks@slashdirt.org>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/**
 * # Zlib bindings
 *
 * The `zlib` module provides single-call and stream-oriented functions for interacting with zlib data.
 *
 * @module zlib
 */

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;assert.h>
#include &lt;errno.h>
#include &lt;zlib.h>

#include "ucode/module.h"
#include "ucode/platform.h"

// https://zlib.net/zlib_how.html

/*
 * CHUNK is simply the buffer size for feeding data to and pulling data from
 * the zlib routines. Larger buffer sizes would be more efficient, especially
 * for inflate(). If the memory is available, buffers sizes on the order of
 * 128K or 256K bytes should be used.
 */
#define CHUNK 16384

static uc_resource_type_t *zstrmd_type, *zstrmi_type;

static int last_error = 0;
#define err_return(err) do { last_error = err; return NULL; } while(0)

typedef struct {
	z_stream strm;
	uc_stringbuf_t *outbuf;
	int flush;
} zstrm_t;

/* zlib init error message */
static const char * ziniterr(int ret)
{
	const char * msg;

	switch (ret) {
	case Z_ERRNO:
		msg = strerror(errno);
		break;
	case Z_STREAM_ERROR:	// can only happen for deflateInit2() by construction
		msg = "invalid compression level";
		break;
	case Z_MEM_ERROR:
		msg = "out of memory";
		break;
	case Z_VERSION_ERROR:
		msg = "zlib version mismatch!";
		break;
	default:
		msg = "unknown error";
		break;
	}

	return msg;
}

static int
def_chunks(zstrm_t * const zstrm)
{
	int ret;

	/* run deflate() on input until output buffer not full */
	do {
		printbuf_memset(zstrm->outbuf, printbuf_length(zstrm->outbuf) + CHUNK - 1, 0, 1);
		zstrm->outbuf->bpos -= CHUNK;

		zstrm->strm.avail_out = CHUNK;
		zstrm->strm.next_out = (unsigned char *)(zstrm->outbuf->buf + zstrm->outbuf->bpos);

		ret = deflate(&amp;zstrm->strm, zstrm->flush);
		assert(ret != Z_STREAM_ERROR);

		zstrm->outbuf->bpos += CHUNK - zstrm->strm.avail_out;
	} while (zstrm->strm.avail_out == 0);
	assert(zstrm->strm.avail_in == 0);	// all input will be used

	return ret;
}

static bool
uc_zlib_def_object(uc_vm_t *const vm, uc_value_t * const obj, zstrm_t * const zstrm)
{
	int ret;
	bool eof = false;
	uc_value_t *rfn, *rbuf;

	rfn = ucv_property_get(obj, "read");

	if (!ucv_is_callable(rfn)) {
		uc_vm_raise_exception(vm, EXCEPTION_TYPE,
				      "Input object does not implement read() method");
		return false;
	}

	do {
		rbuf = NULL;
		uc_vm_stack_push(vm, ucv_get(obj));
		uc_vm_stack_push(vm, ucv_get(rfn));
		uc_vm_stack_push(vm, ucv_int64_new(CHUNK));

		if (uc_vm_call(vm, true, 1) != EXCEPTION_NONE)
			goto fail;

		rbuf = uc_vm_stack_pop(vm);	// read output chunk

		/* we only accept strings */
		if (rbuf != NULL &amp;&amp; ucv_type(rbuf) != UC_STRING) {
			uc_vm_raise_exception(vm, EXCEPTION_TYPE,
					      "Input object read() method returned non-string value");
			goto fail;
		}

		/* check EOF */
		eof = (rbuf == NULL || ucv_string_length(rbuf) == 0);

		zstrm->strm.next_in = (unsigned char *)ucv_string_get(rbuf);
		zstrm->strm.avail_in = ucv_string_length(rbuf);

		zstrm->flush = eof ? Z_FINISH : Z_NO_FLUSH;
		ret = def_chunks(zstrm);
		(void)ret;	// XXX make annoying compiler that ignores assert() happy

		ucv_put(rbuf);	// release rbuf
	} while (!eof);	// finish compression if all of source has been read in
	assert(ret == Z_STREAM_END);	// stream will be complete

	return true;

fail:
	ucv_put(rbuf);
	return false;
}

static bool
uc_zlib_def_string(uc_vm_t * const vm, uc_value_t * const str, zstrm_t * const zstrm)
{
	zstrm->strm.next_in = (unsigned char *)ucv_string_get(str);
	zstrm->strm.avail_in = ucv_string_length(str);

	last_error = def_chunks(zstrm);

	return true;
}

/**
 * Compresses data in Zlib or gzip format.
 *
 * If the input argument is a plain string, it is directly compressed.
 *
 * If an array, object or resource value is given, this function will attempt to
 * invoke a `read()` method on it to read chunks of input text to incrementally
 * compress. Reading will stop if the object's `read()` method returns
 * either `null` or an empty string.
 *
 * Throws an exception on errors.
 *
 * Returns the compressed data.
 *
 * @function module:zlib#deflate
 *
 * @param {string} str_or_resource
 * The string or resource object to be compressed.
 *
 * @param {?boolean} [gzip=false]
 * Add a gzip header if true (creates a gzip-compliant output, otherwise defaults to Zlib)
 *
 * @param {?number} [level=Z_DEFAULT_COMPRESSION]
 * The compression level (0-9).
 *
 * @returns {?string}
 *
 * @example
 * // deflate content using default compression
 * const deflated = deflate(content);
 *
 * // deflate content using fastest compression
 * const deflated = deflate(content, Z_BEST_SPEED);
 */
static uc_value_t *
uc_zlib_deflate(uc_vm_t * const vm, const size_t nargs)
{
	uc_value_t *rv = NULL;
	uc_value_t *src = uc_fn_arg(0);
	uc_value_t *gzip = uc_fn_arg(1);
	uc_value_t *level = uc_fn_arg(2);
	int ret, lvl = Z_DEFAULT_COMPRESSION;
	bool success, gz = false;
	zstrm_t zstrm = {
		.strm = {
			.zalloc = Z_NULL,
			.zfree = Z_NULL,
			.opaque = Z_NULL,
		},
		.outbuf = NULL,
		.flush = Z_FINISH,
	};

	if (gzip) {
		if (ucv_type(gzip) != UC_BOOLEAN) {
			uc_vm_raise_exception(vm, EXCEPTION_TYPE, "Passed gzip flag is not a boolean");
			goto out;
		}

		gz = (int)ucv_boolean_get(gzip);
	}

	if (level) {
		if (ucv_type(level) != UC_INTEGER) {
			uc_vm_raise_exception(vm, EXCEPTION_TYPE, "Passed level is not a number");
			goto out;
		}

		lvl = (int)ucv_int64_get(level);
	}

	ret = deflateInit2(&amp;zstrm.strm, lvl,
			   Z_DEFLATED,		// only allowed method
			   gz ? 15+16 : 15,	// 15 Zlib default, +16 for gzip
			   8,			// default value
			   Z_DEFAULT_STRATEGY);	// default value
	if (ret != Z_OK) {
		uc_vm_raise_exception(vm, EXCEPTION_RUNTIME, "Zlib error: %s", ziniterr(ret));
		goto out;
	}

	zstrm.outbuf = ucv_stringbuf_new();

	switch (ucv_type(src)) {
	case UC_STRING:
		success = uc_zlib_def_string(vm, src, &amp;zstrm);
		break;

	case UC_RESOURCE:
	case UC_OBJECT:
	case UC_ARRAY:
		success = uc_zlib_def_object(vm, src, &amp;zstrm);
		break;

	default:
		uc_vm_raise_exception(vm, EXCEPTION_TYPE,
				      "Passed value is neither a string nor an object");
		printbuf_free(zstrm.outbuf);
		goto out;
	}

	if (!success) {
		if (vm->exception.type == EXCEPTION_NONE)	// do not clobber previous exception
			uc_vm_raise_exception(vm, EXCEPTION_RUNTIME, "Zlib error: %s", zstrm.strm.msg);
		printbuf_free(zstrm.outbuf);
		goto out;
	}

	rv = ucv_stringbuf_finish(zstrm.outbuf);

out:
	(void)deflateEnd(&amp;zstrm.strm);
	return rv;
}

static int
inf_chunks(zstrm_t * const zstrm)
{
	int ret;

	/* run inflate() on input until output buffer not full */
	do {
		printbuf_memset(zstrm->outbuf, printbuf_length(zstrm->outbuf) + CHUNK - 1, 0, 1);
		zstrm->outbuf->bpos -= CHUNK;

		zstrm->strm.avail_out = CHUNK;
		zstrm->strm.next_out = (unsigned char *)(zstrm->outbuf->buf + zstrm->outbuf->bpos);

		ret = inflate(&amp;zstrm->strm, zstrm->flush);
		assert(ret != Z_STREAM_ERROR);
		switch (ret) {
		case Z_NEED_DICT:
		case Z_DATA_ERROR:
		case Z_MEM_ERROR:
			return ret;
		}

		zstrm->outbuf->bpos += CHUNK - zstrm->strm.avail_out;
	} while (zstrm->strm.avail_out == 0);

	return ret;
}

static bool
uc_zlib_inf_object(uc_vm_t *const vm, uc_value_t * const obj, zstrm_t * const zstrm)
{
	int ret = Z_STREAM_ERROR;	// error out if EOF on first loop
	bool eof = false;
	uc_value_t *rfn, *rbuf;

	rfn = ucv_property_get(obj, "read");

	if (!ucv_is_callable(rfn)) {
		uc_vm_raise_exception(vm, EXCEPTION_TYPE,
				      "Input object does not implement read() method");
		return false;
	}

	do {
		rbuf = NULL;
		uc_vm_stack_push(vm, ucv_get(obj));
		uc_vm_stack_push(vm, ucv_get(rfn));
		uc_vm_stack_push(vm, ucv_int64_new(CHUNK));

		if (uc_vm_call(vm, true, 1) != EXCEPTION_NONE)
			goto fail;

		rbuf = uc_vm_stack_pop(vm);	// read output chunk

		/* we only accept strings */
		if (rbuf != NULL &amp;&amp; ucv_type(rbuf) != UC_STRING) {
			uc_vm_raise_exception(vm, EXCEPTION_TYPE,
					      "Input object read() method returned non-string value");
			goto fail;
		}

		/* check EOF */
		eof = (rbuf == NULL || ucv_string_length(rbuf) == 0);
		if (eof)
			break;

		zstrm->strm.next_in = (unsigned char *)ucv_string_get(rbuf);
		zstrm->strm.avail_in = ucv_string_length(rbuf);

		ret = inf_chunks(zstrm);
		switch (ret) {
		case Z_NEED_DICT:
		case Z_DATA_ERROR:
		case Z_MEM_ERROR:
			goto fail;
		}

		ucv_put(rbuf);	// release rbuf
	} while (ret != Z_STREAM_END);	// done when inflate() says it's done

	if (ret != Z_STREAM_END)	// data error
		return false;

	return true;

fail:
	ucv_put(rbuf);
	return false;
}

static bool
uc_zlib_inf_string(uc_vm_t * const vm, uc_value_t * const str, zstrm_t * const zstrm)
{
	int ret;

	zstrm->strm.next_in = (unsigned char *)ucv_string_get(str);
	zstrm->strm.avail_in = ucv_string_length(str);

	ret = inf_chunks(zstrm);
	assert(zstrm->strm.avail_in == 0);
	last_error = ret;

	return Z_STREAM_END == ret;
}

/**
 * Decompresses data in Zlib or gzip format.
 *
 * If the input argument is a plain string, it is directly decompressed.
 *
 * If an array, object or resource value is given, this function will attempt to
 * invoke a `read()` method on it to read chunks of input text to incrementally
 * decompress. Reading will stop if the object's `read()` method returns
 * either `null` or an empty string.
 *
 * Throws an exception on errors.
 *
 * Returns the decompressed data.
 *
 * @function module:zlib#inflate
 *
 * @param {string} str_or_resource
 * The string or resource object to be parsed as JSON.
 *
 * @returns {?string}
 */
static uc_value_t *
uc_zlib_inflate(uc_vm_t * const vm, const size_t nargs)
{
	uc_value_t *rv = NULL;
	uc_value_t *src = uc_fn_arg(0);
	bool success;
	int ret;
	zstrm_t zstrm = {
		.strm = {
			.zalloc = Z_NULL,
			.zfree = Z_NULL,
			.opaque = Z_NULL,
			.avail_in = 0,		// must be initialized before call to inflateInit
			.next_in = Z_NULL,	// must be initialized before call to inflateInit
		},
		.outbuf = NULL,
	};

	/* tell inflateInit2 to perform either zlib or gzip decompression: 15+32 */
	ret = inflateInit2(&amp;zstrm.strm, 15+32);
	if (ret != Z_OK) {
		uc_vm_raise_exception(vm, EXCEPTION_RUNTIME, "Zlib error: %s", ziniterr(ret));
		goto out;
	}

	zstrm.outbuf = ucv_stringbuf_new();

	switch (ucv_type(src)) {
	case UC_STRING:
		zstrm.flush = Z_FINISH;
		success = uc_zlib_inf_string(vm, src, &amp;zstrm);
		break;

	case UC_RESOURCE:
	case UC_OBJECT:
	case UC_ARRAY:
		zstrm.flush = Z_NO_FLUSH;
		success = uc_zlib_inf_object(vm, src, &amp;zstrm);
		break;

	default:
		uc_vm_raise_exception(vm, EXCEPTION_TYPE,
				      "Passed value is neither a string nor an object");
		printbuf_free(zstrm.outbuf);
		goto out;
	}

	if (!success) {
		if (vm->exception.type == EXCEPTION_NONE)	// do not clobber previous exception
			uc_vm_raise_exception(vm, EXCEPTION_RUNTIME, "Zlib error: %s", zstrm.strm.msg);
		printbuf_free(zstrm.outbuf);
		goto out;
	}

	rv = ucv_stringbuf_finish(zstrm.outbuf);

out:
	(void)inflateEnd(&amp;zstrm.strm);
	return rv;
}

/**
 * Represents a handle for interacting with a deflate stream initiated by deflater().
 *
 * @class module:zlib.deflate
 * @hideconstructor
 *
 * @see {@link module:zlib#deflater()}
 *
 * @example
 *
 * const zstrmd = deflater(…);
 *
 * for (let data = ...; data; data = ...) {
 * 	zstrmd.write(data, Z_PARTIAL_FLUSH);	// write uncompressed data to stream
 * 	if (foo)
	* 	let defl = zstrmd.read();	// read back compressed stream content
 * }
 *
 * // terminate the stream at the end of data input to complete a valid archive
 * zstrmd.write(last_data, Z_FINISH);
 * defl = ztrmd.read();
 *
 * zstrmd.error();
 */

/**
 * Initializes a deflate stream.
 *
 * Returns a stream handle on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib#deflater
 *
 * @param {?boolean} [gzip=false]
 * Add a gzip header if true (creates a gzip-compliant output, otherwise defaults to Zlib)
 *
 * @param {?number} [level=Z_DEFAULT_COMPRESSION]
 * The compression level (0-9).
 *
 * @returns {?module:zlib.deflate}
 *
 * @example
 * // initialize a Zlib deflate stream using default compression
 * const zstrmd = deflater();
 *
 * // initialize a gzip deflate stream using fastest compression
 * const zstrmd = deflater(true, Z_BEST_SPEED);
 */
 static uc_value_t *
uc_zlib_deflater(uc_vm_t *vm, size_t nargs)
{
	uc_value_t *gzip = uc_fn_arg(0);
	uc_value_t *level = uc_fn_arg(1);
	int ret, lvl = Z_DEFAULT_COMPRESSION;
	bool gz = false;
	zstrm_t *zstrm;

	zstrm = calloc(1, sizeof(*zstrm));
	if (!zstrm)
		err_return(ENOMEM);

	zstrm->strm.zalloc = Z_NULL;
	zstrm->strm.zfree = Z_NULL;
	zstrm->strm.opaque = Z_NULL;

	if (gzip) {
		if (ucv_type(gzip) != UC_BOOLEAN) {
			last_error = EINVAL;
			goto fail;
		}

		gz = (int)ucv_boolean_get(gzip);
	}

	if (level) {
		if (ucv_type(level) != UC_INTEGER) {
			last_error = EINVAL;
			goto fail;
		}

		lvl = (int)ucv_int64_get(level);
	}

	ret = deflateInit2(&amp;zstrm->strm, lvl,
			   Z_DEFLATED,		// only allowed method
			   gz ? 15+16 : 15,	// 15 Zlib default, +16 for gzip
			   8,			// default value
			   Z_DEFAULT_STRATEGY);	// default value
	if (ret != Z_OK) {
		last_error = ret;
		goto fail;
	}

	return uc_resource_new(zstrmd_type, zstrm);

fail:
	free(zstrm);
	return NULL;
}

/**
 * Writes a chunk of data to the deflate stream.
 *
 * Input data must be a string, it is internally compressed by the zlib `deflate()` routine,
 * the end result is buffered according to the requested `flush` mode until read via
 * {@link module:zlib.zstrmd#read}.
 * Valid `flush`values are `Z_NO_FLUSH` (the default),
 * `Z_SYNC_FLUSH, Z_PARTIAL_FLUSH, Z_FULL_FLUSH, Z_FINISH`.
 * If `flush` is `Z_FINISH` then no more data can be written to the stream.
 * Refer to the {@link https://zlib.net/manual.html Zlib manual} for details
 * on each flush mode.
 *
 * Returns `true` on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib.deflate#write
 *
 * @param {string} src
 * The string of data to deflate.
 *
 * @param {?number} [flush=Z_NO_FLUSH]
 * The zlib flush mode.
 *
 * @returns {?boolean}
 */
static uc_value_t *
uc_zlib_defwrite(uc_vm_t *vm, size_t nargs)
{
	uc_value_t *src = uc_fn_arg(0);
	uc_value_t *flush = uc_fn_arg(1);
	zstrm_t **z = uc_fn_this("zlib.deflate");
	zstrm_t *zstrm;

	if (!z || !*z)
		err_return(EBADF);

	zstrm = *z;

	if (Z_FINISH == zstrm->flush)
		err_return(EPIPE);	// can't reuse a finished stream

	if (flush) {
		if (ucv_type(flush) != UC_INTEGER)
			err_return(EINVAL);

		zstrm->flush = (int)ucv_int64_get(flush);
		switch (zstrm->flush) {
		case Z_NO_FLUSH:
		case Z_SYNC_FLUSH:
		case Z_PARTIAL_FLUSH:
		case Z_FULL_FLUSH:
		case Z_FINISH:
			break;
		default:
			err_return(EINVAL);
		}
	}
	else
		zstrm->flush = Z_NO_FLUSH;

	/* we only accept strings */
	if (!src || ucv_type(src) != UC_STRING)
		err_return(EINVAL);

	if (!zstrm->outbuf)
		zstrm->outbuf = ucv_stringbuf_new();

	return ucv_boolean_new(uc_zlib_def_string(vm, src, zstrm));
}

/**
 * Reads a chunk of compressed data from the deflate stream.
 *
 * Returns the current content of the deflate buffer, fed through
 * {@link module:zlib.deflate#write}.
 *
 * Returns compressed chunk on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib.deflate#read
 *
 * @returns {?string}
 */
static uc_value_t *
uc_zlib_defread(uc_vm_t *vm, size_t nargs)
{
	zstrm_t **z = uc_fn_this("zlib.deflate");
	zstrm_t *zstrm;
	uc_value_t *rv;

	if (!z || !*z)
		err_return(EBADF);

	zstrm = *z;

	if (!zstrm->outbuf)
		err_return(ENODATA);

	if (Z_FINISH == zstrm->flush)
		(void)deflateEnd(&amp;zstrm->strm);

	rv = ucv_stringbuf_finish(zstrm->outbuf);
	zstrm->outbuf = NULL;	// outbuf is now unuseable
	return rv;
}

/**
 * Represents a handle for interacting with an inflate stream initiated by inflater().
 *
 * @class module:zlib.inflate
 * @hideconstructor
 *
 * @borrows module:zlib.deflate#error as module:fs.inflate#error
 *
 * @see {@link module:zlib#inflater()}
 *
 * @example
 *
 * const zstrmi = inflater();
 *
 * for (let data = ...; data; data = ...) {
 * 	zstrmi.write(data, Z_SYNC_FLUSH);	// write compressed data to stream
 * 	if (foo)
	* 	let defl = zstrmi.read();	// read back decompressed stream content
 * }
 *
 * zstrmi.error();
 */

/**
 * Initializes an inflate stream. Can process either Zlib or gzip data.
 *
 * Returns a stream handle on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib#inflater
 *
 * @returns {?module:zlib.inflate}
 *
 * @example
 * // initialize an inflate stream
 * const zstrmi = inflater();
 */
 static uc_value_t *
uc_zlib_inflater(uc_vm_t *vm, size_t nargs)
{
	int ret;
	zstrm_t *zstrm;

	zstrm = calloc(1, sizeof(*zstrm));
	if (!zstrm)
		err_return(ENOMEM);

	zstrm->strm.zalloc = Z_NULL;
	zstrm->strm.zfree = Z_NULL;
	zstrm->strm.opaque = Z_NULL;
	zstrm->strm.avail_in = 0;
	zstrm->strm.next_in = Z_NULL;

	/* tell inflateInit2 to perform either zlib or gzip decompression: 15+32 */
	ret = inflateInit2(&amp;zstrm->strm, 15+32);
	if (ret != Z_OK) {
		last_error = ret;
		goto fail;
	}

	return uc_resource_new(zstrmi_type, zstrm);

fail:
	free(zstrm);
	return NULL;
}

/**
 * Writes a chunk of data to the inflate stream.
 *
 * Input data must be a string, it is internally decompressed by the zlib `inflate()` routine,
 * the end result is buffered according to the requested `flush` mode until read via
 * {@link module:zlib.inflate#read}.
 * Valid `flush` values are `Z_NO_FLUSH` (the default), `Z_SYNC_FLUSH, Z_FINISH`.
 * If `flush` is `Z_FINISH` then no more data can be written to the stream.
 * Refer to the {@link https://zlib.net/manual.html Zlib manual} for details
 * on each flush mode.
 *
 * Returns `true` on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib.inflate#write
 *
 * @param {string} src
 * The string of data to inflate.
 *
 * @param {?number} [flush=Z_NO_FLUSH]
 * The zlib flush mode.
 *
 * @returns {?boolean}
 */
static uc_value_t *
uc_zlib_infwrite(uc_vm_t *vm, size_t nargs)
{
	uc_value_t *src = uc_fn_arg(0);
	uc_value_t *flush = uc_fn_arg(1);
	zstrm_t **z = uc_fn_this("zlib.inflate");
	zstrm_t *zstrm;

	if (!z || !*z)
		err_return(EBADF);

	zstrm = *z;

	if (Z_FINISH == zstrm->flush)
		err_return(EPIPE);	// can't reuse a finished stream

	if (flush) {
		if (ucv_type(flush) != UC_INTEGER)
			err_return(EINVAL);

		zstrm->flush = (int)ucv_int64_get(flush);
		switch (zstrm->flush) {
		case Z_NO_FLUSH:
		case Z_SYNC_FLUSH:
		case Z_FINISH:
			break;
		default:
			err_return(EINVAL);
		}
	}
	else
		zstrm->flush = Z_NO_FLUSH;

	/* we only accept strings */
	if (!src || ucv_type(src) != UC_STRING)
		err_return(EINVAL);

	if (!zstrm->outbuf)
		zstrm->outbuf = ucv_stringbuf_new();

	return ucv_boolean_new(uc_zlib_inf_string(vm, src, zstrm));
}

/**
 * Reads a chunk of decompressed data from the inflate stream.
 *
 * Returns the current content of the inflate buffer, fed through
 * {@link module:zlib.inflate#write}.
 *
 * Returns decompressed chunk on success.
 *
 * Returns `null` if an error occurred.
 *
 * @function module:zlib.inflate#read
 *
 * @returns {?string}
 */
static uc_value_t *
uc_zlib_infread(uc_vm_t *vm, size_t nargs)
{
	zstrm_t **z = uc_fn_this("zlib.inflate");
	zstrm_t *zstrm;
	uc_value_t *rv;

	if (!z || !*z)
		err_return(EBADF);

	zstrm = *z;

	if (!zstrm->outbuf)
		err_return(ENODATA);

	if (Z_FINISH == zstrm->flush)
		(void)inflateEnd(&amp;zstrm->strm);

	rv = ucv_stringbuf_finish(zstrm->outbuf);
	zstrm->outbuf = NULL;	// outbuf is now unuseable
	return rv;
}

/**
 * Queries error information.
 *
 * Returns a string containing a description of the last occurred error or
 * `null` if there is no error information.
 *
 * @function module:zlib.deflate#error
 *
 *
 * @returns {?string}
 */
static uc_value_t *
uc_zlib_error(uc_vm_t *vm, size_t nargs)
{
	uc_value_t *errmsg;

	if (!last_error)
		return NULL;

	// negative last_error only happens for zlib init returns
	errmsg = ucv_string_new(last_error &lt; 0 ? ziniterr(last_error) : strerror(last_error));
	last_error = 0;
	return errmsg;
}

static const uc_function_list_t strmd_fns[] = {
	{ "write",	uc_zlib_defwrite },
	{ "read",	uc_zlib_defread },
	{ "error",	uc_zlib_error },
};

static const uc_function_list_t strmi_fns[] = {
	{ "write",	uc_zlib_infwrite },
	{ "read",	uc_zlib_infread },
	{ "error",	uc_zlib_error },
};

static const uc_function_list_t global_fns[] = {
	{ "deflate",	uc_zlib_deflate },
	{ "inflate",	uc_zlib_inflate },
	{ "deflater",	uc_zlib_deflater },
	{ "inflater",	uc_zlib_inflater },
};

static void destroy_zstrmd(void *z)
{
	zstrm_t *zstrm = z;

	if (zstrm) {
		(void)deflateEnd(&amp;zstrm->strm);
		printbuf_free(zstrm->outbuf);
		free(zstrm);
	}
}

static void destroy_zstrmi(void *z)
{
	zstrm_t *zstrm = z;

	if (zstrm) {
		(void)inflateEnd(&amp;zstrm->strm);
		printbuf_free(zstrm->outbuf);
		free(zstrm);
	}
}

void uc_module_init(uc_vm_t *vm, uc_value_t *scope)
{
	uc_function_list_register(scope, global_fns);

	zstrmd_type = uc_type_declare(vm, "zlib.deflate", strmd_fns, destroy_zstrmd);
	zstrmi_type = uc_type_declare(vm, "zlib.inflate", strmi_fns, destroy_zstrmi);

#define ADD_CONST(x) ucv_object_add(scope, #x, ucv_int64_new(x))

	/**
	 * @typedef
	 * @name Compression levels
	 * @description Constants representing predefined compression levels.
	 * @property {number} Z_NO_COMPRESSION.
	 * @property {number} Z_BEST_SPEED.
	 * @property {number} Z_BEST_COMPRESSION.
	 * @property {number} Z_DEFAULT_COMPRESSION - default compromise between speed and compression (currently equivalent to level 6).
	 */
	ADD_CONST(Z_NO_COMPRESSION);
	ADD_CONST(Z_BEST_SPEED);
	ADD_CONST(Z_BEST_COMPRESSION);
	ADD_CONST(Z_DEFAULT_COMPRESSION);

	/**
	 * @typedef
	 * @name flush options
	 * @description Constants representing flush options.
	 * @property {number} Z_NO_FLUSH.
	 * @property {number} Z_PARTIAL_FLUSH.
	 * @property {number} Z_SYNC_FLUSH.
	 * @property {number} Z_FULL_FLUSH.
	 * @property {number} Z_FINISH.
	 */
	ADD_CONST(Z_NO_FLUSH);
	ADD_CONST(Z_PARTIAL_FLUSH);
	ADD_CONST(Z_SYNC_FLUSH);
	ADD_CONST(Z_FULL_FLUSH);
	ADD_CONST(Z_FINISH);
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button> <button class="icon-button" id="mobile-toc" data-isopen="false" aria-label="toc"><svg><use xlink:href="#toc-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">ucode Documentation</a><div class="mobile-nav-links"><div class="github-home navbar-item"><a id="" href="https://github.com/jow-/ucode" target="">GitHub Project Page</a></div></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="Mn2ZtWaSCf8lxqBM30jM0"><div>Tutorials</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="tutorial-01-usage.html">Usage</a></div><div class="sidebar-section-children"><a href="tutorial-02-syntax.html">Syntax</a></div><div class="sidebar-section-children"><a href="tutorial-03-memory.html">Memory Management</a></div><div class="sidebar-section-children"><a href="tutorial-04-arrays.html">Working with Arrays</a></div><div class="sidebar-section-children"><a href="tutorial-05-dictionaries.html">Working with Dictionaries</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="P3uD-u9aSgJIACEZlfa4D"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-core.html">core</a></div><div class="sidebar-section-children"><a href="module-debug.html">debug</a></div><div class="sidebar-section-children"><a href="module-digest.html">digest</a></div><div class="sidebar-section-children"><a href="module-fs.html">fs</a></div><div class="sidebar-section-children"><a href="module-log.html">log</a></div><div class="sidebar-section-children"><a href="module-math.html">math</a></div><div class="sidebar-section-children"><a href="module-resolv.html">resolv</a></div><div class="sidebar-section-children"><a href="module-socket.html">socket</a></div><div class="sidebar-section-children"><a href="module-struct.html">struct</a></div><div class="sidebar-section-children"><a href="module-uci.html">uci</a></div><div class="sidebar-section-children"><a href="module-uloop.html">uloop</a></div><div class="sidebar-section-children"><a href="module-zlib.html">zlib</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#dark-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div><div class="navbar-right-item toc-item"><button class="icon-button toc" aria-label="open-table-of-contents"><svg><use xlink:href="#toc-icon"></use></svg></button></div></div></div></div><div id="mobile-tocbar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><span class="sidebar-title">Table of Contents</span><div class="toc-contents"></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#mobile-tocbar > .mobile-sidebar-wrapper > .toc-contents",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:(...e)=>{hideMobileMenu(),bringLinkToView(...e)},includeHtml:!0})</script></body></html>